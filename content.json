{"pages":[{"title":"关于我","text":"&emsp;&emsp;还没有想好该怎么样介绍自己，那就先这样吧！ &emsp;&emsp;我养了两只猫，一只叫豆浆，一只叫油条。","link":"/about/index.html"},{"title":"标签","text":"","link":"/tags/index.html"},{"title":"分类","text":"","link":"/categories/index.html"}],"posts":[{"title":"Spring AOP的实现原理","text":"1.Spring中关于AOP的定义如下:&emsp;&emsp;面向切面——Spring提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务（例如审计（auditing）和事务（transaction）管理）进行内聚性的开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责（甚至是意识）其它的系统级关注点，例如日志或事务支持。 &emsp;&emsp;面向切面是面向对象的一种方式，在代码执行的过程当中，动态嵌入其它代码。 &emsp;&emsp;常见使用场景:&emsp;&emsp;1.日志&emsp;&emsp;2.事务&emsp;&emsp;3.数据库操作 2.AOP的几个核心概念&emsp;&emsp;AOP本质上是Java动态代理 通知(Advice)5种通知类型: Before 在方法被调用之前调用 After 在方法完成后调用通知，无论方法是否执行成功 After-returning 在方法成功执行之后调用通知 After-throwing 在方法抛出异常后调用通知 Around 环绕通知，在被通知的方法之前或者之后自定义是否执行被通知的方法 切点(Pointcut)切点在Spring AOP中对应系统中的方法,这个方法是定义在切面中的方法，一般和通知一起使用，一起组成了切面。 连接点(Join point)连接点就是准备在系统中执行切点和切入通知的地方(一般是一个方法，一个字段) 切面(Aspect)切面是切点和通知的集合，一般单独作为一个类。通知和切点共同定义了关于切面的全部内容，在何时和何处完成什么功能。 引入(Introduction)引入允许我们向现有的类添加新的方法或者属性。 织入(Weaving)创建一个被通知对象。这可以在编译时完成（例如使用AspectJ编译器），也可以在运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。 3.Spring中对AOP的支持&emsp;&emsp;首先AOP思想的实现一般都是基于代理模式，在JAVA中一般采用JDK动态代理模式，但是我们都知道，JDK动态代理模式只能代理接口，如果要代理类那么就不行了。因此，Spring AOP 会这样子来进行切换，因为Spring AOP 同时支持 CGLIB、ASPECTJ、JDK动态代理，当你的真实对象有实现接口时，Spring AOP会默认采用JDK动态代理，否则采用cglib代理。 如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类。 如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类——不过这个选择过程对开发者完全透明、开发者也无需关心。 4.代码实现Java动态代理(定义一个计算器作为例子) 定义一个接口12345public interface Calculator { int add(int a, int b); void min(int a, int b);} 定义接口的实现类1234567891011121314public class CalculatorImpl implements Calculator { //有返回值 @Override public int add(int a, int b) { System.out.println(a + &quot;+&quot; + b + &quot;=&quot; + (a + b)); return a + b; } //无返回值 @Override public void min(int a, int b) { System.out.println(a + &quot;-&quot; + b + &quot;=&quot; + (a - b)); }} 动态代理类1234567891011121314151617181920212223242526public class MyProxy { /** * @param o 被代理的对象 * @return 返回值是代理后的对象 */ public Object getInstance(Object o){ return Proxy.newProxyInstance(o.getClass().getClassLoader(), o.getClass().getInterfaces(), new InvocationHandler() { /** * 被代理过后的对象返回值变为invoke方法的返回值 * @param proxy 被代理的对象 * @param method 被代理的方法 * @param args 被代理的方法的参数 * @return 方法的返回值 * @throws Throwable */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { long start = System.nanoTime(); Object invoke = method.invoke(o, args); long end = System.nanoTime(); System.out.println(end - start); return invoke; } }); }} main方法12345678public class Main { public static void main(String[] args) { //获取代理对象 Calculator instance = (Calculator) new MyProxy().getInstance(new CalculatorImpl()); instance.add(9,8); instance.min(4,5); }} &emsp;&emsp;被动态代理过后的对象可以轻松的进行如打印日志等的操作，AOP的引入可以更加灵活方便，实现动态配置。","link":"/2020/02/16/aop/"},{"title":"面试前的一些针对性复习计划","text":"1.准备面试的公司技术要求 熟练掌握IDEA开发工具，良好的编码习惯和风格 熟练SpringMVC、SpringBoot、mybatis等开发框架 良好的数据库知识mysql、redis、oracle、MQ等，强sql能力 熟练使用linux常用命令、环境配置 熟练使用Tomcat、Nginx等服务部署 熟悉maven环境 了解前端具备一定的开发经验，基本掌握：html、html5、css、css3，熟练掌握js代码编写，页面兼容性处理。 熟练运用关系型数据库：mysql/oracle，具备一定的数据库表设计经验 2.自己不足的地方和学习计划 SpringMVC，熟悉一下xml配置和框架流程 mybatis熟悉一下相关的标签和注解 redis和MQ掌握一下高级用法，实际写点demo 熟悉Nginx服务部署 熟悉maven私服 熟悉js代码，jQuery 3.鼓励一下自己&emsp;&emsp;有多个前后端分离全栈开发经验，熟练使用vue和element-ui，前端应该不存在多大问题，了解一下性能优化。每天按着计划多复习和学习一点东西，找工作的时候肯定没问题。不用害怕面试，面试只不过是对自己技术做一个测试而已。踏踏实实的做好每一步，必能有所收获。","link":"/2020/02/15/interview/"},{"title":"重写equals方法为什么要重写hashcode?","text":"1.要讨论这个问题必须先明白==和equals的区别&emsp;&emsp;== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)。 &emsp;&emsp;equals():它的作用也是判断两个对象是否相等。但它一般有两种使用情况： 情况1：类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于通过”==”比较这两个对象。 情况2：类覆盖了equals()方法。一般，我们都覆盖equals()方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。 &emsp;&emsp;基本数据类型的包装类为引用类型，其中的equals()方法等价于”==”,以下为Integer的equals()方法: 1234567public boolean equals(Object obj) { if (obj instanceof Integer) { return this.value == (Integer)obj; } else { return false; }} &emsp;&emsp;String的equsle()方法被重写过，比较的是对象的值是否相等。 1234567891011121314public boolean equals(Object anObject) { if (this == anObject) { return true; } else { if (anObject instanceof String) { String aString = (String)anObject; if (this.coder() == aString.coder()) { return this.isLatin1() ? StringLatin1.equals(this.value, aString.value) : StringUTF16.equals(this.value, aString.value); } } return false; }} &emsp;&emsp;object的equals()方法比较的是对象的内存地址是否相等。 123public boolean equals(Object obj) { return this == obj;} 2.什么是hashcode()?&emsp;&emsp;hashcode()的作用是获取哈希码，返回一个int类型的整数。哈希码的作用是确定对象在哈希表中的索引位置。hashCode()定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode()函数。计算hash值是根据对象堆内存上地址转换成一个整数hash值。 引用JavaGuide教程里面的一段话:3.为什么要有hashCode&emsp;&emsp;我们先以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode： 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashCode 值作比较，如果没有相符的hashCode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashCode 值的对象，这时会调用 equals()方法来检查 hashCode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。 4.hashCode与equals()的相关规定 如果两个对象相等，则hashCode一定相同 两个对象相等，两个对象分别调用equals()方法都返回true 两个对象有相同的hashCode值，它们不一定相同(两个对象hashCode的值相同，但是equals为false，就会被散列在散列表的不同位置) hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode(),则该class的两个对象无论如何都不会相等(即使这两个对象是相同的数据) 因此，equals()方法被覆盖过，则hashCode()方法也必须被覆盖 5.为什么重写equals()方法的时候必须要重写hashCode()?&emsp;&emsp;重写equals()的目的是有的时候我们只需要判断两个对象的某些属性相等就认为它们相等，如果此时不重写hashCode(),基于堆内存地址的散列值除非产生hash冲突，那不然两个对象hashCode()必定不相等。如果不重写hashCode(),两个逻辑上相等的对象会被散列在散列表的不同位置。 重写equals()，重写hashCode(): 123456789101112 Book b1 = new Book(1,&quot;三国演义&quot;,&quot;罗贯中&quot;); Book b2 = new Book(1,&quot;三国演义&quot;,&quot;罗贯中&quot;); System.out.println(b1.equals(b2)); System.out.println(b1==b2); System.out.println(b1.hashCode()); System.out.println(b2.hashCode());运行结果: true false 1993172716 1993172716 重写equals()，不重写hashCode(): 123456789101112 Book b1 = new Book(1,&quot;三国演义&quot;,&quot;罗贯中&quot;); Book b2 = new Book(1,&quot;三国演义&quot;,&quot;罗贯中&quot;); System.out.println(b1.equals(b2)); System.out.println(b1==b2); System.out.println(b1.hashCode()); System.out.println(b2.hashCode());运行结果: true false 1989495347 614635686 6.补充：什么是堆内存和栈内存？ 在Java中，栈(stack)是由编译器自动分配和释放的一块内存区域，主要用于存放一些基本类型（如int、float等）的变量、指令代码、常量及对象句柄（也就是对象的引用地址） 堆（heap）是一个程序运行动态分配的内存区域，在Java中，构建对象时所需要的内存从堆中分配。这些对象通过new指令“显式”建立，这种分配方式类似于数据结构中的链表。堆内存在使用完毕后，是由垃圾回收（Garbage Collection,GC）器“隐式”回收的。","link":"/2020/02/15/equals-hashcode/"},{"title":"Nginx初级教程(二)Nginx常用的命令","text":"进入nginx目录 1cd usr/local/nginx/sbin 查看nginx版本号 1./nginx -v 启动nginx 1./nginx 关闭nginx 1./nginx -s stop 重新加载nginx 1./nginx -s reload","link":"/2020/02/20/nginx-2/"},{"title":"Hello World","text":"&emsp;&emsp;国际惯例，先来一篇Hello，World! &emsp;&emsp;终于完成了一直以来的一个梦想，搭建一个属于自己的博客。记录一下学习到的新技术，偶尔记录一下生活上的趣事也是极好的。博客采用了hexo，主题采用了icarus，项目仓库在GitHub。由于GitHub Pages的访问速度太慢了，所以就将仓库关联到了Gitee，托管在了Gitee Pages。由于域名还在备案的流程当中，所以暂时用了Gitee二级域名，后面会换到自己的域名。https://www.zlgwzy.com &emsp;&emsp;接下来就是把以前做的笔记整理一下上传到博客，方便以后回顾，同时也加深了印象。 &emsp;&emsp;由于疫情的原因，一直宅在家学习准备面试。希望早点控制好疫情，就能够出去找工作面试了，希望能找到满意的工作。","link":"/2020/02/15/hello-world/"},{"title":"Nginx初级教程(四)Nginx配置实例-反向代理","text":"1.实现效果 浏览器访问某个域名,跳转到服务器部署的tomcat首页 根据请求路径的不同，跳转到不同的tomcat端口(准备两个tomcat，8080和8081端口) 2.准备工作 安装nginx 安装并启动tomcat(使用默认8080端口，阿里云安全组配置开放8080端口) 在windows的host文件进行配置域名映射的ip地址(浏览器访问先去windows下的host文件查找IP地址和域名映射关系) 1234#进入C:\\Windows\\System32\\drivers#打开hosts文件，在最后一行添加如下内容你的Linux服务器IP地址 www.zlgwzy.com(用来测试的域名) 在nginx做请求转发的配置 12cd usr/local/nginx/confvi nginx.conf 启动nginx 12cd usr/local/nginx/sbin./nginx 3.通过不同的路径，转发到不同的tomcat端口 准备两个tomcat服务器，8080和8081端口 123cd usr/srcmkdir tomcat8080mkdir tomcat8081 将tomcat分别放到两个文件夹并进行解压 查看是否有tomcat进程，有的话进行强杀 12ps -ef | grep tomcatkill -9 pid(进程id) 启动8080端口 启动8081端口(需要修改配置文件) 123#进入解压过后的tomcat目录cd confvi server.xml 准备测试文件(方便验证确实跳转到不同的tomcat端口)&emsp;&emsp;在两个tomcat的webapps目录下分别创建8080和8081文件夹，并在文件夹里面分别创建index.html 配置nginx反向代理 12cd usr/local/nginx/confvi nginx.conf 重新启动nginx 123cd usr/local/nginx/sbin./nginx -s stop./nginx 验证","link":"/2020/02/21/nginx-4/"},{"title":"Nginx初级教程(三)Nginx中的配置文件","text":"进入nginx下的conf目录(配置文件名为nginx.conf) 1cd usr/local/nginx/conf nginx.conf的组成 nginx配置文件的组成三部分 全局块&emsp;&emsp;从配置文件开始到events块之间的内容，主要会设置一些影响Nginx服务器整体运行的配置指令，主要包括配置运行Nginx服务器的用户（组）、允许生成的worker process数，进程 PID 存放路径、日志存放路径和类型以 及配置文件的引入等。 events块&emsp;&emsp; events块涉及的指令主要影响Nginx服务器与用户的网络连接，常用的设置包括是否开启对多work process下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个word process可以同时支持的最大连接数等。 http块( 每个http块可以包括多个server块，而每个server块就相当于一个虚拟主机。)&emsp;&emsp; 这算是 Nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。需要注意的是：http块也可以包括 http全局块、server 块。 http中全局块&emsp;&emsp; http全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。 http中server块(而每个server块也分为全局块，以及可以同时包含多个locaton 块。 ) 全局块(最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或IP配置。) location块( 一个server块可以配置多个location块。)&emsp;&emsp; 这块的主要作用是基于Nginx服务器接收到的请求字符串（例如 server_name/uri-string），对虚拟主机名称 （也可以是IP 别名）之外的字符串（例如 前面的 /uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓 存和应答控制等功能，还有许多第三方模块的配置也在这里进行。 nginx.conf123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117 #user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events { worker_connections 1024;}http { include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] &quot;$request&quot; ' # '$status $body_bytes_sent &quot;$http_referer&quot; ' # '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server { listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / { root html; index index.html index.htm; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ { # proxy_pass http://127.0.0.1; #} # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ { # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #} # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht { # deny all; #} } # another virtual host using mix of IP-, name-, and port-based configuration # #server { # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / { # root html; # index index.html index.htm; # } #} # HTTPS server # #server { # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / { # root html; # index index.html index.htm; # } #}}","link":"/2020/02/21/nginx-3/"},{"title":"Nginx初级教程(六)Nginx配置实例-动静分离","text":"1.什么是动静分离？&emsp;&emsp;nginx动静分离就是将动态请求和静态请求分开，一般来说是nginx处理静态请求，tomcat处理动态请求。 2.动静分离的一般实现 静态文件放到单独的服务器(主流方案) 动态和静态文件混合发布，通过nginx分开&emsp;&emsp;通过location指定不同的后缀名实现不同的请求转发。通过expires参数设置，可以使浏览器缓存过期时间，减少与服务器之前的请求和流量。具体 Expires定义：是给一个资源设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，所以不会产生额外的流量。此种方法非常适合不经常变动的资源。（如果经常更新的文件， 不建议使用 Expires 来缓存），我这里设置2d，表示在这2天之内访问这个URL，发送一个请求，比对服务器该文件最后更新时间没有变化，则不会从服务器抓取，返回状态码 304，如果有修改，则直接从服务器重新下载，返回状态码 200。 3.准备静态资源用于进行访问 在根目录下创建data文件夹 data文件夹里面创建www和images文件夹 www里面存放index.html images里面存放spider.jpg 4.在nginx文件中进行配置 12cd usr/local/nginx/confvi nginx.conf 5.访问测试","link":"/2020/02/21/nginx-6/"},{"title":"SpringMVC中文件上传和踩坑记录","text":"1.SpringMVC中的两个文件上传处理器 CommonsMultipartResolver(兼容Servlet3.0之前的版本，需要 commons-fileupload 依赖) StandardServletMultipartResolver(适用于 Servlet3.0 之后的版本，不需要依赖) 2.CommonsMultipartResolver(上传文件的实现) 添加commons-fileupload依赖1234&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;&lt;/dependency&gt; SpringMVC配置文件中配置MultipartResolver1&lt;bean class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot; id=&quot;multipartResolver&quot;/&gt; 创建jsp页面123456789101112&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/doUpload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 文件上传接口12345678910111213141516171819202122232425262728 @RequestMapping(&quot;/doUpload&quot;) @ResponseBody public String doUpload(MultipartFile file, HttpServletRequest request) { String format = simpleDateFormat.format(new Date()); //上传文件到当前项目运行目录下 String realPath = request.getServletContext().getRealPath(&quot;/images&quot;) + format;// String realPath = &quot;F:/images&quot; + format; File folder = new File(realPath); //判断文件夹是否存在 if (!folder.exists()) { folder.mkdirs(); } //获取上传文件的文件名 String oldName = file.getOriginalFilename(); //UUID生成随机字符串，字符串截取生成新的文件名 String newName = UUID.randomUUID().toString() + oldName.substring(oldName.lastIndexOf(&quot;.&quot;)); try { //将文件写入到目标文件夹并重命名 file.transferTo(new File(folder, newName)); //返回上传的文件路径 String url = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + &quot;/images&quot; + format + newName;// String url = &quot;file:///&quot; + realPath + newName; return url; } catch (IOException e) { e.printStackTrace(); } return &quot;上传失败！&quot;; } 自定义上传文件配置123456789101112&lt;bean class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot; id=&quot;multipartResolver&quot;&gt; &lt;!--默认的编码--&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;/&gt; &lt;!--上传的总文件大小--&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;1048576&quot;/&gt; &lt;!--上传的单个文件大小--&gt; &lt;property name=&quot;maxUploadSizePerFile&quot; value=&quot;1048576&quot;/&gt; &lt;!--内存中最大的数据量，超过这个数据量，数据就要开始往硬盘中写了--&gt; &lt;property name=&quot;maxInMemorySize&quot; value=&quot;4096&quot;/&gt; &lt;!--临时目录，超过 maxInMemorySize 配置的大小后，数据开始往临时目录写，等全部上传完成后，再将数据合并到正式的文件上传目录--&gt; &lt;property name=&quot;uploadTempDir&quot; value=&quot;file:///E:\\\\tmp&quot;/&gt;&lt;/bean&gt; 3.StandardServletMultipartResolver(上传文件的实现) SpringMVC 的配置文件中，配置这个 Bean12&lt;bean class=&quot;org.springframework.web.multipart.support.StandardServletMultipartResolver&quot; id=&quot;multipartResolver&quot;&gt;&lt;/bean&gt; 即使不需要限制文件上传大小，也需要在 web.xml 中配置 multipart-config12345678910111213141516171819202122&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;multipart-config&gt; &lt;!--文件保存的临时目录，这个目录系统不会主动创建--&gt; &lt;location&gt;E:\\\\temp&lt;/location&gt; &lt;!--上传的单个文件大小--&gt; &lt;max-file-size&gt;1048576&lt;/max-file-size&gt; &lt;!--上传的总文件大小--&gt; &lt;max-request-size&gt;1048576&lt;/max-request-size&gt; &lt;!--这个就是内存中保存的文件最大大小--&gt; &lt;file-size-threshold&gt;4096&lt;/file-size-threshold&gt; &lt;/multipart-config&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 4.踩坑记录 SpringMVC 的配置文件中，配置CommonsMultipartResolver或者StandardServletMultipartResolver的时候必须指定id为multipartResolver StandardServletMultipartResolver实现文件上传，即使不需要限制文件上传大小，也需要在 web.xml 中配置 multipart-config 生成文件夹目录的过程中，创建文件夹由于是多层文件夹mkdirs()不要写成mkdir() MultipartFile 取别名的时候一定要和上传文件的控件中的name名称一致，要不然获取不到文件抛空指针异常 上传图片生成的静态资源文件被自动拦截，在SpringMVC的配置文件中添加配置如下:1&lt;mvc:resources mapping=&quot;/**&quot; location=&quot;/&quot;/&gt; 5.多文件上传的实现(参考自江南一点雨的springmvc教程) key相同的文件 用MultipartFile[]数组接收，上传文件用for循环处理，上传的控件加上multiple属性1234&lt;form action=&quot;/upload2&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;files&quot; multiple&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt;&lt;/form&gt; key不相同的文件 定义多个不同的变量接收，分别进行文件重命名，创建文件的处理","link":"/2020/02/19/upload/"},{"title":"Nginx初级教程(五)Nginx配置实例-负载均衡","text":"1.实现效果 访问同一个地址，将请求均衡负载到不同的tomcat服务器 2.准备工作 准备两个tomcat服务器，分别开放8080和8081端口，分别在webapps目录下创建balance目录，放入index.html 访问测试 在Nginx中的配置文件进行负载均衡相关配置 12cd usr/local/nginx/confvi nginx.conf nginx.conf配置文件 验证(Nginx会将请求均衡负载到不同的tomcat) 3.Nginx负载均衡的分配策略1. 轮询(默认)(每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器宕机，能自动剔除。) 2. weight(weight代表权,重默认为1,权重越高被分配的客户端越多。) upstream myserver { server 47.97.220.152:8080 weight=5; server 47.97.220.152:8081 weight=10; } 3. ip_hash(按照访问ip的hash结果分配，每个ip固定访问一个后端服务器，解决session共享问题) upstream myserver { ip_hash; server 47.97.220.152:8080 weight=5; server 47.97.220.152:8081 weight=10; } 4. fair(按照后端服务器的响应时间，响应时间短的优先被分配请求。) upstream myserver { server 47.97.220.152:8080; server 47.97.220.152:8081; fair; }","link":"/2020/02/21/nginx-5/"},{"title":"SpringMVC中json处理和踩坑记录","text":"1.三种主流的json处理工具 jackson gson fastjson&emsp;&emsp;在 SpringMVC 中，对 jackson 和 gson 都提供了相应的支持，就是如果使用这两个作为 JSON 转换器，只需要添加对应的依赖就可以了，返回的对象和返回的集合、Map 等都会自动转为 JSON，但是，如果使用 fastjson，除了添加相应的依赖之外，还需要自己手动配置 HttpMessageConverter 转换器。其实前两个也是使用 HttpMessageConverter 转换器，但是是 SpringMVC 自动提供的，SpringMVC 没有给 fastjson 提供相应的转换器。 2.jackson 添加依赖12345678910 &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.10.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.9&lt;/version&gt;&lt;/dependency&gt; 后端返回的对象通过 HttpMessageConverter 自动转为 JSON 字符串。 返回json数组1234567891011121314 @RequestMapping(&quot;/books&quot;)@ResponseBodypublic List&lt;Book&gt; getBooks() { List&lt;Book&gt; books = new ArrayList&lt;Book&gt;(); for (int i = 0; i &lt; 10; i++) { Book book = new Book(); book.setId(i); book.setName(&quot;SpringBoot + Vue 全栈开发实战&quot;); book.setAuthor(&quot;王松&quot;); book.setPublish(new Date()); books.add(book); } return books;} 自定义日期格式(将注解加到实体类上，可以作用于实体类的所有日期属性上)12//在实体类的日期属性上加上注解@JsonFormat(pattern = &quot;yyyy-MM-dd&quot;,timezone = &quot;Asia/Shanghai&quot;) 自定义日期格式，全局配置1234567891011121314151617181920 &lt;mvc:annotation-driven&gt; //提供一个converter &lt;mvc:message-converters&gt; &lt;ref bean=&quot;httpMessageConverter&quot;/&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt;//定义一个converter&lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot; id=&quot;httpMessageConverter&quot;&gt; &lt;property name=&quot;objectMapper&quot;&gt; &lt;bean class=&quot;com.fasterxml.jackson.databind.ObjectMapper&quot;&gt; &lt;property name=&quot;dateFormat&quot;&gt; &lt;bean class=&quot;java.text.SimpleDateFormat&quot;&gt; &lt;constructor-arg name=&quot;pattern&quot; value=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;property name=&quot;timeZone&quot; value=&quot;Asia/Shanghai&quot;/&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt; 3.gson(同时存在jackson和gson,默认使用jackson) Goole推出的json解析器，SpringMVC提供了对应的自动化配置，只需要加入gson依赖。12345 &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.8.6&lt;/version&gt;&lt;/dependency&gt; gosn的自定义配置(全局自定义日期格式):12345678910111213&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters&gt; &lt;ref bean=&quot;httpMessageConverter&quot;/&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt;&lt;bean class=&quot;org.springframework.http.converter.json.GsonHttpMessageConverter&quot; id=&quot;httpMessageConverter&quot;&gt; &lt;property name=&quot;gson&quot;&gt; &lt;bean class=&quot;com.google.gson.Gson&quot; factory-bean=&quot;gsonBuilder&quot; factory-method=&quot;create&quot;/&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean class=&quot;com.google.gson.GsonBuilder&quot; id=&quot;gsonBuilder&quot;&gt; &lt;property name=&quot;dateFormat&quot; value=&quot;yyyy-MM-dd&quot;/&gt;&lt;/bean&gt; 3.fastjson(SpringMVC中无自动化配置，手动配置HttpMessageConverter) fastjson依赖12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.60&lt;/version&gt;&lt;/dependency&gt; SpringMVC的配置文件中配置HttpMessageConverter:123456789101112&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters&gt; &lt;ref bean=&quot;httpMessageConverter&quot;/&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt;&lt;bean class=&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter&quot; id=&quot;httpMessageConverter&quot;&gt; &lt;property name=&quot;fastJsonConfig&quot;&gt; &lt;bean class=&quot;com.alibaba.fastjson.support.config.FastJsonConfig&quot;&gt; &lt;property name=&quot;dateFormat&quot; value=&quot;yyyy-MM-dd&quot;/&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt; fastjson中文乱码解决1234567891011121314151617&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters&gt; &lt;ref bean=&quot;httpMessageConverter&quot;/&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt;&lt;bean class=&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter&quot; id=&quot;httpMessageConverter&quot;&gt; &lt;property name=&quot;fastJsonConfig&quot;&gt; &lt;bean class=&quot;com.alibaba.fastjson.support.config.FastJsonConfig&quot;&gt; &lt;property name=&quot;dateFormat&quot; value=&quot;yyyy-MM-dd&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;property name=&quot;supportedMediaTypes&quot;&gt; &lt;list&gt; &lt;value&gt;application/json;charset=utf-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 5.json接收 在 Jsp/Servlet中，接收key/value形式的参数，一般是通过getParameter方法。如果客户端上传的是JSON数据，我们可以通过如下格式进行解析： 1234567 @RequestMapping(&quot;/addbook2&quot;) @ResponseBody public void addBook2(HttpServletRequest req) throws IOException { ObjectMapper om = new ObjectMapper(); Book book = om.readValue(req.getInputStream(), Book.class); System.out.println(book); } SpringMVC中通过注解将前端传来的json字符串转为对象，直接将注解加在方法参数的前面 6.踩坑记录 IDEA开发工具下SpringMVC使用jackson，依赖没有导入到编译环境，导致找不到对应的converter(点击Project Structure下的Project Settings中的Artifacts，将右侧新增的依赖双击加入到项目的编译环境中) 不同的json解析器有不同的配置方式，fastjson在SpringMVC下必须手动配置httpMessageConverter 全局配置不一定任何时候都适用，根据具体情况而定","link":"/2020/02/19/json/"},{"title":"Nginx初级教程(七)Nginx配置实例-高可用的集群(主从模式)","text":"1.什么是高可用？ &emsp;&emsp;高可用HA（High Availability）是分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计减少系统不能提供服务的时间。假设系统一直能够提供服务，我们说系统的可用性是100%。如果系统每运行100个时间单位，会有1个时间单位无法提供服务，我们说系统的可用性是99%。 2.反向代理层实现高可用 3.准备工作 准备两台服务器192.168.0.109和192.168.0.110 在两台服务器安装nginx 在两台服务器安装keepalived 1234#安装yum install keepalived -y#查看是否安装rpm -q -a keepalived 修改keepalived.conf(位于/etc/keepalived目录下) 123456789101112131415161718192021222324252627282930313233343536#全局定义global_defs { notification_email { #指定keepalived在发生切换时需要发送email的列表 mili_work@163.com 727910064@qq.com } notification_email_from mili_work@163.com #指定发件人 smtp_server 192.168.200.1 #绑定smtp服务器地址 smtp_connect_timeout 30 #smtp连接超时时间 router_id LVS_DEVEL #访问到主机}vrrp_script check_nginx { script &quot;/etc/keepalived/check_nginx.sh&quot; ##监控脚本 interval 2 ##时间间隔，2秒 weight 2 ##权重}vrrp_instance VI_1 { state BACKUP #备份服务器上将 MASTER 改为 BACKUP interface enp0s3 #实例绑定的网卡 (ifconfig查看第一个参数) virtual_router_id 51 #VRRP组名，主、备机的 virtual_router_id 必须相同 priority 90 #主、备机取不同的优先级，主机值较大，备份机值较小 advert_int 1 #主从负载均衡器同步检查时间间隔 authentication { #主从服务器验证方式 auth_type PASS auth_pass 1111 } track_script { check_nginx #监控脚本 } virtual_ipaddress { 192.168.0.222 #VRRP H 虚拟地址 需要和nginx的IP在同一网段，多个虚拟IP换行即可 192.168.0.33 }} 准备check—_ngixn.sh脚本(放在/etc/keepalived目录下,keepalived检查进程是否存在进行主从切换，nginx检查脚本通过检查nginx进程是否存在来决定是否结束keepalived进程，从而进行了主从切换) 123456789101112131415#!/bin/bashA=`ps -C nginx --no-header |wc -l` if [ $A -eq 0 ];then /usr/local/nginx/sbin/nginx #如果检测到nginx挂掉了就重启nginx if [ `ps -C nginx --no-header |wc -l` -eq 0 ];then #nginx重启失败，则停掉keepalived服务，进行VIP转移 killall keepalived fifi 启动两台服务器的nginx和keepalived 123456#启动nginxcd usr/local/nginx/sbin./nginx#启动keepalivedsystemctl start keepalived.service#手动启动nginx检查脚本 测试 注意事项(check_nginx脚本的执行权限，shell脚本的文件格式) 12#修改当前脚本的执行权限为可读可写可执行chmod 777 check_nginx.sh","link":"/2020/02/22/nginx-7/"},{"title":"物流管理项目记录(一)项目基本搭建","text":"1.搭建好SSM项目 2.利用工具生成model和mapper(采用mybatis-generator-core-1.3.1) &emsp;&emsp;修改model里面的属性名称，重新生成get/set方法，修改mapper将字段名称和数据库表中的字段统一(规范命名，采用小驼峰命名法) 3.加入mybatis相关依赖和数据库驱动，以及Druid数据库连接池，JDBC(事务)，shiro，单元测试，aop，jackson 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.17&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.20&lt;/version&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.8.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-web&lt;/artifactId&gt; &lt;version&gt;1.5.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.5.0&lt;/version&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.1.8.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.8.12&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.12&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.8&lt;/version&gt;&lt;/dependency&gt; 4.创建数据库配置文件db.properties 123db.username=rootdb.password=123456db.url=jdbc:mysql:///wlgl?useUnicode=true&amp;characterEncoding=UTF-8 5.在spring配置文件中引入数据库配置文件，配置Druid以及mybatis和事务 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!--引入数据库配置文件--&gt;&lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt;&lt;!--配置Druid--&gt;&lt;bean class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; id=&quot;dataSource&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;${db.url}&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;${db.username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${db.password}&quot;/&gt;&lt;/bean&gt;&lt;!--配置mybatis--&gt;&lt;bean class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot; id=&quot;sqlSessionFactory&quot;&gt; &lt;!--连接数据库的数据源，这里是Druid--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!--实体类所在的包--&gt; &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.zlgwzy.wlgl.model&quot;/&gt; &lt;!-- 当mybatis的xml文件和mapper接口不在相同包下时，需要用mapperLocations属性指定xml文件的路径 *是个通配符，代表所有的文件，**代表所有目录下 --&gt; &lt;property name=&quot;mapperLocations&quot;&gt; &lt;list&gt; &lt;value&gt;classpath*:com/zlgwzy/wlgl/mapper/*.xml&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!--mapper接口所在位置--&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.zlgwzy.wlgl.mapper&quot;/&gt; &lt;property name=&quot;beanName&quot; value=&quot;sqlSessionFactory&quot;/&gt;&lt;/bean&gt;&lt;!--配置事务管理器--&gt;&lt;bean class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot; id=&quot;transactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;add*&quot;/&gt; &lt;tx:method name=&quot;insert*&quot;/&gt; &lt;tx:method name=&quot;delete*&quot;/&gt; &lt;tx:method name=&quot;update*&quot;/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;aop:config&gt; &lt;!--定义切点，返回值任意，service包下的任意类下的任意方法，任意参数个数和类型--&gt; &lt;aop:pointcut id=&quot;pc1&quot; expression=&quot;execution(* com.zlgwzy.wlgl.service.*.*(..))&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pc1&quot;/&gt;&lt;/aop:config&gt;","link":"/2020/02/23/wlgl-1/"},{"title":"SSM项目搭建图文教程","text":"1.构建maven工程 2.将普通maven项目改造为web项目 3.添加SpringMVC依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.8.RELEASE&lt;/version&gt;&lt;/dependency&gt; 4.创建spring的配置和springmvc的配置 5.spring配置文件applicationContext.xml 1234&lt;!--spring配置文件里面扫描除了controller以外的内容--&gt;&lt;context:component-scan base-package=&quot;com.zlgwzy.wlgl&quot; use-default-filters=&quot;true&quot;&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;&lt;/context:component-scan&gt; 6.springmvc配置文件spring-servlet.xml 123456789101112&lt;!--springmvc配置文件只扫描controller--&gt;&lt;context:component-scan base-package=&quot;com.zlgwzy.wlgl&quot; use-default-filters=&quot;false&quot;&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;&lt;/context:component-scan&gt;&lt;!--自动注册RequestMappingHandlerMapping，RequestMappingHandlerAdapter，exceptionHandlerExceptionResolver--&gt;&lt;mvc:annotation-driven/&gt;&lt;!--静态资源过滤--&gt;&lt;mvc:resources mapping=&quot;/**&quot; location=&quot;/&quot;/&gt;&lt;!--配置视图解析器--&gt; 7.web.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!--配置spring--&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!--配置监听器：启动Web容器时，自动装配applicationContext的配置信息--&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;!--配置springmvc--&gt;&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;!--配置字符编码和响应编码--&gt;&lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceRequestEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;","link":"/2020/02/23/springmvc/"},{"title":"物流管理项目记录(二)SpringMVC整合shiro","text":"1.添加shiro相关依赖(搭建过程中已添加)2.shiro相关配置 1234567891011121314151617181920212223242526272829303132&lt;!--自定义LoginRealm--&gt;&lt;bean class=&quot;com.zlgwzy.wlgl.realm.LoginRealm&quot; id=&quot;loginRealm&quot;&gt; &lt;!--配置加密匹配--&gt; &lt;property name=&quot;credentialsMatcher&quot;&gt; &lt;bean class=&quot;org.apache.shiro.authc.credential.HashedCredentialsMatcher&quot;&gt; &lt;property name=&quot;hashIterations&quot; value=&quot;1024&quot;/&gt; &lt;property name=&quot;hashAlgorithmName&quot; value=&quot;SHA-512&quot;/&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!--配置securityManager--&gt;&lt;bean class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot; id=&quot;securityManager&quot;&gt; &lt;property name=&quot;realm&quot; ref=&quot;loginRealm&quot;/&gt;&lt;/bean&gt;&lt;!--配置shiroFilter拦截需要权限控制的url--&gt;&lt;bean class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot; id=&quot;shiroFilter&quot;&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt; &lt;property name=&quot;loginUrl&quot; value=&quot;/login&quot;/&gt; &lt;property name=&quot;filterChainDefinitions&quot;&gt; &lt;value&gt; /logout=logout /doLogin=anon /index.html=anon /static/**=anon /truck/**=authc,roles[运输管理员] /task/**=authc,roles[承运业务员] /**=authc &lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; 3.自定义LoginRealm 1234567891011121314151617181920212223242526272829303132public class LoginRealm extends AuthorizingRealm { @Autowired UserService userService; @Autowired RoleService roleService; @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) { Integer roleID = ((User) SecurityUtils.getSubject().getSession().getAttribute(&quot;user&quot;)).getFk_roleID(); Role role = roleService.getRoleById(roleID); Set&lt;String&gt; roles = new HashSet&lt;String&gt;(); roles.add(role.getRoleName()); return new SimpleAuthorizationInfo(roles); } @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) { //账号为string，密码为char[] String account = (String) authenticationToken.getPrincipal(); User user = userService.getUserByAccount(account); //避免user为null，手动在这里抛出异常 if (user == null) { throw new UnknownAccountException(); } //将用户信息保存到session Session session = SecurityUtils.getSubject().getSession(); session.setAttribute(&quot;user&quot;, user); ByteSource salts = ByteSource.Util.bytes(user.getAccount()); return new SimpleAuthenticationInfo(user.getAccount(), user.getPassword(), salts, getName()); }} 4.LoginController 1234567891011121314151617181920212223242526272829@RestControllerpublic class LoginController { @PostMapping(&quot;/doLogin&quot;) public RespBean login(@RequestBody User user) throws AuthenticationException{ //获取token UsernamePasswordToken token = new UsernamePasswordToken(user.getAccount(), user.getPassword()); Subject subject = SecurityUtils.getSubject(); try { subject.login(token); /*登录成功返回信息到前端，以及user对象用户信息*/ User obj = (User) subject.getSession().getAttribute(&quot;user&quot;); obj.setPassword(null); return RespBean.ok(&quot;登录成功！&quot;, obj); } catch (AuthenticationException e) { if (e instanceof UnknownAccountException){ return RespBean.error(&quot;账户不正确！&quot;); } if (e instanceof IncorrectCredentialsException) { return RespBean.error(&quot;密码不正确！&quot;); } } return RespBean.error(&quot;登录失败！&quot;); } @GetMapping(&quot;/login&quot;) public RespBean login(){ return RespBean.error(&quot;尚未登录，请登录！&quot;); }} 5.登录流程 UsernamePasswordToken获取前端传递的account和password，SecurityUtils.getSubject().login(token)执行登录。LoginRealm里authenticationToken.getPrincipal()获取account执行service层查询sql，避免无查询结果却写入seession抛出空指针异常，判断查询结果是否为null，手动抛出UnknownAccountException。 123&lt;!--传入加密算法的salt，传入account，password，realmName(在xml里面找到加密算法的名称，迭代次数)，返回到login流程继续处理--&gt;ByteSource salts = ByteSource.Util.bytes(user.getAccount());return new SimpleAuthenticationInfo(user.getAccount(), user.getPassword(), salts, getName());在login过程中捕获这些异常，返回对应的json提示,未捕获的异常直接返回失败！","link":"/2020/02/24/wlgl-2/"},{"title":"SpringBoot读取配置的几种方式以及优先级","text":"1.通过@ConfigurationProperties读取、配置文件中的数据并与bean绑定,使用@Component注解可以像普通bean一样注入 12345678910111213141516171819202122@Component@ConfigurationProperties(prefix = &quot;pc&quot;)public class Computer { private String type; private float price; //省略get/set/toString方法//application.properties添加如下配置pc.type=notbookpc.price=6500//controller@RestControllerpublic class ComputerController { @Autowired Computer computer; @GetMapping(&quot;/computer&quot;) public String computer(){ return computer.toString(); }} 2.通过@PropertySource读取指定properties文件(yaml不支持该注解加载配置文件) 1234567891011121314151617181920212223@Component@PropertySource(&quot;classpath:other.properties&quot;)public class Book { @Value(&quot;${book.name}&quot;) private String name; @Value(&quot;${book.author}&quot;) private String author;}//other.propertiesbook.name=三国演义book.author=罗贯中@RestControllerpublic class BookController { @Autowired Book book; @GetMapping(&quot;/book&quot;) public String book(){ return book.toString(); }} 3.SpringBoot配置文件加载的优先级","link":"/2020/02/27/springboot-config/"},{"title":"物流管理项目记录(三)搭建前端项目","text":"1.创建项目(确认已安装node，npm，vuecli，npm切换到cnpm淘宝源) 2.配置端口转发(node.js和tomcat都要占用端口，开发环境存在跨域) 123456789 proxyTable: { '/':{ target:'http://localhost:8081', changeOrigin: true, pathRewrite:{ '^/':'' } }} 3.去掉App.vue默认样式，删除默认模板相关文件 1234567891011121314&lt;template&gt;&lt;div id=&quot;app&quot;&gt; &lt;router-view/&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {name: 'App'}&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 4.引入ElementUI，axios 12345678910111213141516171819//命令行安装依赖cnpm install axioscnpm i element-ui -S//main.js引入ElementUIimport ElementUI from 'element-ui';import 'element-ui/lib/theme-chalk/index.css';Vue.use(ElementUI,{size:'small'});//导入网络请求工具里面的组件，定义为全局组件import {postKeyValueRequest} from &quot;./utils/api&quot;;import {getRequest} from &quot;./utils/api&quot;;import {postRequest} from &quot;./utils/api&quot;;import {deleteRequest} from &quot;./utils/api&quot;;import {putRequest} from &quot;./utils/api&quot;;Vue.prototype.postKeyValueRequest = postKeyValueRequest;Vue.prototype.getRequest = getRequest;Vue.prototype.postRequest = postRequest;Vue.prototype.deleteRequest = deleteRequest;Vue.prototype.putRequest = putRequest; 5.封装好的网络请求工具 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109import axios from 'axios'import {Message} from 'element-ui'/*请求拦截器*/axios.interceptors.request.use(config =&gt; {return config;}, err =&gt; {Message.error({message: '请求超时!',center:true});})/*响应拦截器* 定义了data，里面有data{}和status，data{}为返回的responseBean* data:{status:200,msg:&quot;&quot;,obj:{}},status:200}status分别为请求响应值的200和http的200* */axios.interceptors.response.use(data =&gt; {if (data.status &amp;&amp; data.status == 200 &amp;&amp; data.data.status == 500) { //业务逻辑错误 //例如登陆失败时，请求响应值为500，http的status为200 Message.error({message: data.data.msg,center:true}); //请求失败直接return，不返回任何数据，方法不继续执行 return;}/*后端返回的信息*/if (data.data.msg) { Message.success( {message: data.data.msg,center:true} );}//在方法调用的位置返回服务器返回的数据return data.data;}, err =&gt; {if (err.response.status == 504 || err.response.status == 404) { Message.error({message: '服务器被吃了⊙﹏⊙∥',center:true});} else if (err.response.status == 403) { Message.error({message: '权限不足,请联系管理员!',center:true});} else if (err.response.status == 401) { Message.error({message: '权限不足,请联系管理员!',center:true});} else { if (err.response.data.msg) { Message.error({message: err.response.data.msg,center:true}); } else { Message.error({message: '未知错误!',center:true}); }}})/** base为请求前缀* */let base = '';export const postKeyValueRequest = (url, params) =&gt; {return axios({ method: 'post', url: `${base}${url}`, data: params, transformRequest: [function (data) { let ret = '' for (let it in data) { ret += encodeURIComponent(it) + '=' + encodeURIComponent(data[it]) + '&amp;' } return ret }], headers: { 'Content-Type': 'application/x-www-form-urlencoded' } }); } export const postRequest = (url, params) =&gt; { return axios({ method: 'post', url: `${base}${url}`, data: params, headers: { 'Content-Type': 'application/json' } }); } export const upLoadFileRequest = (url, params) =&gt; { return axios({ method: 'post', url: `${base}${url}`, data: params, headers: { 'Content-Type': 'multipart/form-data' } }); } export const putRequest = (url, params) =&gt; { return axios({ method: 'put', url: `${base}${url}`, data: params, headers: { 'Content-Type': 'application/json' } }); } export const deleteRequest = (url) =&gt; { return axios({ method: 'delete', url: `${base}${url}` }); } export const getRequest = (url) =&gt; { return axios({ method: 'get', url: `${base}${url}` }); } 6.修改index.html(避免页面存在内外边距) 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt; &lt;title&gt;物流管理&lt;/title&gt;&lt;/head&gt;&lt;body style=&quot;margin: 0px;padding: 0px&quot;&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;!-- built files will be auto injected --&gt;&lt;/body&gt;&lt;/html&gt; 7.根据业务在component目录下创建对应的包和.vue文件，并在router的index.js里面导入组件，配置对应的路由","link":"/2020/02/24/wlgl-3/"},{"title":"SpringBoot实现过滤器","text":"1.什么是过滤器？Filter过滤器主要是用来过滤用户请求，它允许我们对用户请求进行前置处理和后置处理。实现 URL 级别的权限控制、过滤非法请求等等。Filter过滤器是面向切面编程——AOP思想的的具体实现。 Filter依赖Servlet容器，属于Servlet规范的一部分。 2.如何实现自定义Filter？实现自定义Filter，只需实现javax.servlet.Filter接口，然后重写里面的3个方法。 123456789101112131415161718//Filter所在的包package javax.servlet;import java.io.IOException;public interface Filter { //初始化Filter后执行的操作 default void init(FilterConfig filterConfig) throws ServletException { } //对请求进行过滤操作 void doFilter(ServletRequest var1, ServletResponse var2, FilterChain var3) throws IOException, ServletException; //销毁过滤器后执行的操作，主要对用户资源进行回收 default void destroy() { }} 3.Filter实现拦截 Filter中的doFilter方法实现了对用户请求的过滤 用户发送请求到web服务器，请求先到达过滤器 过滤器会过滤用户的请求参数，修改返回到客户端的response，判断用户是否拥有访问该接口的权限 用户请求响应完毕、 其他操作 4.实现自定义Filter的两种方法(手动注册配置，使用@WebFilter注解) 自定义Filter123456789101112131415161718192021222324252627@Componentpublic class MyFilter implements Filter { private static final Logger logger = getLogger(MyFilter.class); @Override public void init(FilterConfig filterConfig) throws ServletException { logger.info(filterConfig.getFilterName() + &quot;开始执行init!&quot;); } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { logger.info(&quot;开始执行doFilter!&quot;); HttpServletRequest request = ((HttpServletRequest) servletRequest); String requestURI = request.getRequestURI(); System.out.println(&quot;请求的接口为：&quot; + requestURI); long start = System.currentTimeMillis(); //执行过滤器链 filterChain.doFilter(servletRequest, servletResponse); long end = System.currentTimeMillis(); System.out.println(&quot;请求处理完毕，总消耗:&quot; + (end - start) + &quot;ms&quot;); } @Override public void destroy() { logger.info(&quot;开始执行destroy!&quot;); }} MyFilterConfig自定义Filter配置123456789101112131415@Configurationpublic class MyFilterConfig { @Autowired MyFilter myFilter; @Bean public FilterRegistrationBean&lt;MyFilter&gt; myFilterFilterRegistrationBean(){ //实例化filterRegistrationBean FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean&lt;&gt;(); //设置Filter filterRegistrationBean.setFilter(myFilter); //设置拦截规则 filterRegistrationBean.setUrlPatterns(new ArrayList&lt;&gt;(Arrays.asList(&quot;/api/*&quot;))); return filterRegistrationBean; }} @WebFilter注解实现Filter123456789101112131415161718192021222324252627@WebFilter(filterName = &quot;MyFilterWithAnnotation&quot;,urlPatterns = &quot;/api/*&quot;)public class MyFilterWithAnnotation implements Filter { private static final Logger logger = getLogger(MyFilter.class); @Override public void init(FilterConfig filterConfig) throws ServletException { logger.info(filterConfig.getFilterName() + &quot;开始执行init!&quot;); } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { logger.info(&quot;开始执行doFilter!&quot;); HttpServletRequest request = ((HttpServletRequest) servletRequest); String requestURI = request.getRequestURI(); System.out.println(&quot;请求的接口为：&quot; + requestURI); long start = System.currentTimeMillis(); //执行过滤器链 filterChain.doFilter(servletRequest, servletResponse); long end = System.currentTimeMillis(); System.out.println(&quot;请求处理完毕，总消耗:&quot; + (end - start) + &quot;ms&quot;); } @Override public void destroy() { logger.info(&quot;开始执行destroy!&quot;); }} 5.定义多个拦截器的执行顺序通过FilterRegistrationBean的setOrder方法可以决定Filter的执行顺序。","link":"/2020/02/27/springboot-filter/"},{"title":"从零开始部署一个Java项目(基于centos7环境)","text":"1.项目部署需要的准备工作 一台服务器(云服务器或物理服务器) 安装jdk 安装tomcat 安装mysql 安装nginx 2.安装JDK 查看可以安装的java环境 1yum -y list java* 安装jkd 12#不带devel后缀的是jreyum install -y java-1.8.0-openjdk-devel.x86_64 查看jdk版本 1java -version 2.安装tomcat tomcat官网下载安装包 将下载好的tomcat放在/local/src目录下并解压 1tar -zxvf apache-tomcat-9.0.31.tar.gz 开放端口 123456//查看防火墙列表firewall-cmd --list-all//添加端口firewall-cmd --zone=public --add-port=8080/tcp --permanent//更改防火墙需重新加载配置firewall-cmd --reload 启动tomcat 启动tomcat的三种方式 * 直接启动 ./startup.sh 作为服务启动 nohup ./startup.sh &amp; 初次使用的情况下会提示权限不足 chmod +x *.sh 使用该命令给.sh提供权限 控制台动态输出方式启动 ./catalina.sh run 动态地显示tomcat后台的控制台输出信息,Ctrl+C后退出并关闭服务 参考文章：linux下启动tomcat服务的命令是什么 查看tomcat启动效果 3.安装myslq(5.6) 下载yum源(无法使用wget，yum install wget 安装wget) 1wget http://repo.mysql.com/mysql-community-release-el6-5.noarch.rpm 安装mysql yum源(rpm文件下载到执行wget命令的目录下,el7对应centos7) 1rpm -ivh mysql-community-release-el6-5.noarch.rpm 安装mysql 1yum install mysql-community-server -y 设置开机自启(2,3,4都为开) 12chkconfig --list | grep mysqldchkconfig mysqld on 启动mysql 1service mysqld start 设置密码 1mysql_secure_installation 建立远程root用户 12mysql&gt; GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '你设置的密码' WITH GRANT OPTION;mysql&gt; flush privileges; 开放3306端口 12firewall-cmd --zone=public --add-port=3306/tcp --permanentfirewall-cmd --reload 修改字符编码为utf8 ![修改etc目录下的my.cnf](/images/QQ截图20200301182158.jpg) ![重启mysql，查看字符编码](/images/QQ截图20200301182103.jpg) 4.安装nginx参考文章：Nginx初级教程(一)Nginx概述与安装 5.前端项目打包dist文件夹下的内容移动到后端项目的static目录下，打包项目为可执行jar6.服务器运行可执行jar图片上传的demo可正常运行","link":"/2020/03/01/linux-new/"},{"title":"SpringBoot整合Thymeleaf","text":"1.Thymeleaf介绍Thymeleaf是新一代Java模板引擎，支持HTML原型，为Spring官方推荐的模板引擎。 2.使用Thymeleaf需要添加Thymeleaf依赖 1234&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 3.默认的资源路径Spring会去resources目录下templates目录下找，所以建议把页面放在resources/templates目录下。 4.bean 12345public class Pet { private String name; private String category; //省略get/set方法} 5.controller 1234567891011//返回视图的时候根据请求地址去找对应的模板，也可以手动设置视图名称@RestControllerpublic class PetController { @GetMapping(&quot;/pet&quot;) public ModelAndView pet(@RequestParam(name = &quot;name&quot;) String name, @RequestParam(name = &quot;category&quot;, required = false, defaultValue = &quot;动物&quot;) String category, Model model){ ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(&quot;name&quot;, name); modelAndView.addObject(&quot;category&quot;, category); return modelAndView; }} 6.视图 1234567891011121314151617181920&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;/&gt; &lt;title&gt;我的宠物&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;类别&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td th:text=&quot;${name}&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;${category}&quot;&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 7.测试结果 8.返回指定视图的几种方式 是默认在resources目录下的templates中，请求地址为”/pet”,直接去templates中找名为pet的视图模板 请求地址为”/pet/pet”,去templates中的pet目录下找名为pet的视图模板 请求地址为”/pet”，但是视图在templates目录下的某目录下(如test)，手动设置视图名称 modelAndView.setViewName(“/test/pet”)","link":"/2020/02/27/springboot-thymeleaf/"},{"title":"SpringBoot中的静态资源访问","text":"1.SSM中的配置在SSM环境中，我们在springmv配置文件中配置不拦截静态资源有xml配置和java配置两种方法。 xml配置 1&lt;mvc:resources mapping=&quot;/**&quot; location=&quot;/&quot;/&gt; java配置 12345678@Configuration@ComponentScan(basePackages = &quot;com.zlgwzy.demo&quot;)public class WebConfig implements WebMvcConfigurer { @Override protected void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(&quot;/**&quot;).addResourceLocations(&quot;/&quot;); }} 2.SpringBoot中的配置(4个静态资源的存放位置) 系统默认创建了”classpath:/static/“ 3.SpringBoot自定义拦截规则和静态资源位置(properties和java配置两种方式) 123456789101112//application.propertiesspring.mvc.static-path-pattern=/images/**spring.resources.static-locations=classpath:/static/images//java配置@Configurationpublic class WebConfig implements WebMvcConfigurer { @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(&quot;/images/**&quot;).addResourceLocations(&quot;/static/images&quot;); }} 4.实现效果","link":"/2020/02/28/springboot-resource/"},{"title":"SpringBoot实现拦截器","text":"1.什么是拦截器？拦截器(Interceptor)同过滤器(Filter)一样，都是面向切面编程——AOP思想的具体实现。 拦截器可以在Controller处理请求之前编写日志，添加或更新配置。 在 Spring中，当请求发送到Controller时，在被Controller处理之前，它必须经过Interceptors（0或更多）。 2.拦截器和过滤器的区别 3.自定义Interceptor如果你需要自定义 Interceptor 的话必须实现 org.springframework.web.servlet.HandlerInterceptor接口或继承 org.springframework.web.servlet.handler.HandlerInterceptorAdapter类，并且需要重写下面3个方法： 12345678910111213141516public class MyInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { return false; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { }} 4.自定义拦截器实现重定向 1234567891011121314151617181920212223242526272829303132333435public class OldLoginInterceptor implements HandlerInterceptor { /** * preHandle方法返回 true或 false。如果返回 true，则意味着请求将继续到达 Controller 被处理。 * @param request * @param response * @param handler * @return * @throws Exception */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { long start = System.currentTimeMillis(); System.out.println(&quot;请求到达：MyInterceptor.preHandle()&quot;); System.out.println(&quot;请求URL:&quot; + request.getRequestURL()); request.setAttribute(&quot;start&quot;, start); response.sendRedirect(request.getContextPath() + &quot;/api/login&quot;); return false; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(&quot;请求到达：MyInterceptor.postHandle()&quot;); System.out.println(&quot;请求URL:&quot; + request.getRequestURL()); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(&quot;请求到达：MyInterceptor.afterCompletion()&quot;); long start = ((Long) request.getAttribute(&quot;start&quot;)); long end = System.currentTimeMillis(); System.out.println(&quot;请求URL:&quot; + request.getRequestURL()); System.out.println(&quot;耗时：&quot; + (end-start) + &quot;ms&quot;); }} 5.注册拦截器 1234567891011121314151617181920 @Configurationpublic class WebConfig implements WebMvcConfigurer { /** * 配置类实现WebMvcConfigurer接口，重写addInterceptors方法注册拦截器 * @param registry */ @Override public void addInterceptors(InterceptorRegistry registry) { //拦截所有请求,除去&quot;/api/*&quot; registry.addInterceptor(new MyInterceptor()) .excludePathPatterns(&quot;/api/*&quot;); //拦截&quot;/api/old&quot;请求 registry.addInterceptor(new OldLoginInterceptor()) .addPathPatterns(&quot;/api/old&quot;); //拦截所以&quot;/api/*&quot;请求，除去&quot;/api/old&quot; registry.addInterceptor(new NewLoginInterceptor()) .addPathPatterns(&quot;/api/*&quot;) .excludePathPatterns(&quot;/api/old&quot;); }} 6.controller 123456789101112@Controllerpublic class InterceptorTestController { @GetMapping(value = {&quot;/&quot;,&quot;/test&quot;}) public String test(Model model){ return &quot;test&quot;; } @GetMapping(value = &quot;/api/login&quot;) public String login(Model model){ return &quot;login&quot;; }} 7.页面模板 12345678910111213141516171819202122232425262728293031323334353637383940//login&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;SpringBoot实现拦截器&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;a th:href=&quot;@{/}&quot;&gt;test&lt;/a&gt; &amp;nbsp;&amp;nbsp; | &amp;nbsp;&amp;nbsp; &lt;a th:href=&quot;@{/api/old}&quot;&gt;/api/old(过期的接口)&lt;/a&gt;&lt;/div&gt;&lt;h3&gt;SpringBoot实现拦截器-------这里是login页面&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt;//test&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;SpringBoot实现拦截器&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;a th:href=&quot;@{/}&quot;&gt;test&lt;/a&gt; &amp;nbsp;&amp;nbsp; | &amp;nbsp;&amp;nbsp; &lt;a th:href=&quot;@{/api/old}&quot;&gt;/api/old(过期的接口)&lt;/a&gt;&lt;/div&gt;&lt;h3&gt;SpringBoot实现拦截器-------这里是test页面&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 8.404错误重定向 12345678910111213141516171819202122232425262728293031323334353637public class MyInterceptor implements HandlerInterceptor { /** * preHandle方法返回 true或 false。如果返回 true，则意味着请求将继续到达 Controller 被处理。 * @param request * @param response * @param handler * @return * @throws Exception */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { long start = System.currentTimeMillis(); System.out.println(&quot;请求到达：MyInterceptor.preHandle()&quot;); System.out.println(&quot;请求URL:&quot; + request.getRequestURL()); request.setAttribute(&quot;start&quot;, start); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { final int notfound = 404; System.out.println(&quot;请求到达：MyInterceptor.postHandle()&quot;); System.out.println(&quot;请求URL:&quot; + request.getRequestURL()); if (response.getStatus() == notfound){ response.sendRedirect(&quot;/api/404&quot;); } } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(&quot;请求到达：MyInterceptor.afterCompletion()&quot;); long start = ((Long) request.getAttribute(&quot;start&quot;)); long end = System.currentTimeMillis(); System.out.println(&quot;请求URL:&quot; + request.getRequestURL()); System.out.println(&quot;耗时：&quot; + (end-start) + &quot;ms&quot;); }}","link":"/2020/02/27/springboot-interceptor/"},{"title":"了解一下@ControllerAdvice注解","text":"@ControllerAdvice是一个增强的 Controller。使用这个 Controller ，可以实现三个方面的功能： 全局异常处理 全局数据绑定 全局数据预处理 1.全局异常处理 123456789101112131415161718//手动抛出一个异常@Controllerpublic class UploadController{ @GetMapping(&quot;/api/upload&quot;) public void upload(){ throw new MaxUploadSizeExceededException(1024); }}//捕获异常，返回对应的json@ControllerAdvice@ResponseBodypublic class CustomExceptionHandler { @ExceptionHandler(MaxUploadSizeExceededException.class) public RespBean uploadException(MaxUploadSizeExceededException e){ return RespBean.error(&quot;上传文件大小超出限制！&quot;); }} 2.全局数据绑定 123456789101112131415161718192021222324252627282930313233@ControllerAdvicepublic class GlobalConfig { /** * @return 方法的返回值为map，key为info */ @ModelAttribute(value = &quot;info&quot;) public Map&lt;String,String&gt; userInfo(){ HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;name&quot;, &quot;mili&quot;); map.put(&quot;email&quot;, &quot;mili_work@163.com&quot;); return map; }}@RestControllerpublic class UserInfoController { @GetMapping(&quot;/api/hello&quot;) public void hello(Model model){ //Map&lt;&quot;info&quot;,Map&gt; Map&lt;String,Object&gt; map = model.asMap(); //获取map里面全部的key Set&lt;String&gt; keySet = map.keySet(); System.out.println(keySet); //迭代器迭代所有的key Iterator&lt;String&gt; iterator = keySet.iterator(); while (iterator.hasNext()){ String key = iterator.next(); Object value = map.get(key); System.out.println(key + &quot;&gt;&gt;&gt;&gt;&gt;&quot; + value); } }} 3.全局数据预处理当一个controller需要接受两个实体类的时候，若属性的名称出现重复，就会发生混淆。 1234567891011121314151617181920212223@RestControllerpublic class BookController { @Autowired Book book; @Autowired Author author; @PostMapping(&quot;/book&quot;) public String book(@ModelAttribute(&quot;a&quot;) Book book,@ModelAttribute(&quot;b&quot;) Author author){ return book.toString() + &quot;&gt;&gt;&gt;&gt;&gt;&quot; +author.toString(); }}//设置前缀 @InitBinder(&quot;a&quot;)public void init1(WebDataBinder webDataBinder){ webDataBinder.setFieldDefaultPrefix(&quot;a.&quot;);}@InitBinder(&quot;b&quot;)public void init2(WebDataBinder webDataBinder){ webDataBinder.setFieldDefaultPrefix(&quot;b.&quot;);}","link":"/2020/02/28/springboot-ControllerAdvice/"},{"title":"Nginx初级教程(一)Nginx概述与安装","text":"1.什么是Nginx？&emsp;&emsp;Nginx是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx可以作为一个HTTP web服务器，反向代理作为负载均衡服务器，邮件代理服务器。 正向代理进行上网等功能(通过配置客户端，通常是浏览器) 反向代理(客户端无需配置，暴露反向代理服务器，隐藏真实服务器地址。请求发送到反向代理服务器，反向代理服务器选择目标服务器获取数据返回给客户端) 负载均衡(通过集群增加服务器的数量，nginx将请求均衡分发到不同的服务器上，缓解传统单个服务器承受的高负载) 动静分离(动态页面和静态页面由不同的服务器解析，nginx将请求分发到不同的动静态资源服务器) 2.安装Nginx(环境:阿里云服务器 centos7) 下载相关的依赖 gcc(Nginx使用c语言开发，编译依赖gcc环境)1yum install gcc-c++ pcer和pcre-devel(Nginx的http模块使用pcre解析正则表达式)1yum install -y pcre pcre-devel zlib和zlib-devel(Nginx使用zlib对http包进行解压)1yum install -y zlib zlib-devel OpenSSL和OpenSSL-devel(Nginx支持https，在ssl协议上传输http)1yum install -y openssl openssl-devel 一键安装以上的四个依赖1yum install -y gcc-c++ pcre pcre-devel zlib zlib-devel openssl openssl-devel 进入Nginx官网获取当前稳定版本(Stable version) 12//进入到centos下 /usr/src 通过wget下载(速度慢可以直接在本地下载上传到centos)wget -c https://nginx.org/download/nginx-1.16.1.tar.gz 当前目录下解压Nginx 1tar -xvf nginx-1.16.1.tar.gz 进入到Nginx目录，编译安装 123cd nginx-1.16.1./configuremake &amp;&amp; make install /usr/local下已创建nginx文件夹(Nginx启动脚本在sbin目录下) 123cd usr/local/nginx/sbin//启动Nginx./nginx 查看Nginx进程 1ps -ef | grep nginx 查看配置文件(默认监听服务器的80端口) 12cd usr/local/nginx/conf查看nginx.conf 防火墙配置(centos7) //查看防火墙列表 firewall-cmd --list-all //添加端口 sudo firewall-cmd --zone=public --add-port=80/tcp --permanent //更改防火墙需重新加载配置 firewall-cmd --reload 访问服务器地址加端口(出现Nginx欢迎页面！)","link":"/2020/02/20/nginx-1/"},{"title":"SpringMVC工作原理详解(转载自SnailClimb在GitHub的开源项目JavaGide)","text":"原作者开源项目地址 JavaGuide 1.先来看一下什么是MVC模式&emsp;&emsp;MVC是一种设计模式&emsp;&emsp;MVC的原理图如下: 2.SpringMVC简单介绍&emsp;&emsp;SpringMVC框架是以请求为驱动,围绕Servlet设计,将请求发给控制器,然后通过模型对象,分派器来展示请求结果视图。其中核心类是 DispatcherServlet,它是一个Servlet,顶层是实现的Servlet接口。 3.SpringMVC使用&emsp;&emsp;需要在web.xml中配置DispatcherServlet。并且需要配置Spring监听器ContextLoaderListener 12345678910111213141516171819&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt;&lt;/listener&gt;&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet &lt;/servlet-class&gt; &lt;!-- 如果不设置init-param标签，则必须在/WEB-INF/下创建xxx-servlet.xml文件，其中xxx是servlet-name中配置的名称。 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 4.SpringMVC工作原理(重要)简单来说:&emsp;&emsp;客户端发送请求-&gt;前端控制器DispatcherServlet接受客户端请求-&gt;找到处理器映射HandlerMapping解析请求对应的Handler-&gt;HandlerAdapter会根据Handler来调用真正的处理器处理请求,并处理相应的业务逻辑-&gt;处理器返回一个模型视图ModelAndView-&gt;视图解析器进行解析-&gt;返回一个视图对象-&gt;前端控制器DispatcherServlet渲染数据(Moder)-&gt;将得到视图对象返回给用户。如下图所示: 流程说明(重要): 客户端(浏览器)发送请求,直接请求到DispatcherServlet。 DispatcherServlet根据请求信息调用HandlerMapping,解析请求对应的Handler。 解析到对应的Handler(也就是我们平常说的Controller控制器)后,开始由HandlerAdapter适配器处理。 HandlerAdapter会根据Handler来调用真正的处理器处理请求,并处理相应的业务逻辑。 处理器处理完业务后,会返回一个ModelAndView对象,Model是返回的数据对象,View是个逻辑上的View。 ViewResolver会根据逻辑View查找实际的View。 DispaterServlet把返回的Model传给View(视图渲染) 把View返回给请求者(浏览器) 5.SpringMVC重要组件说明 前端控制器DispatcherServlet(不需要工程师开发),由框架提供(重要)作用:SpringMVC的入口函数。接收请求,响应结果,相当于转发器,中央处理器。有了DispatcherServlet减少了其它组件之间的耦合度。用户请求到达前端控制器,它就相当于mvc模式中的c,DispatcherServlet是整个流程控制的中心,由它调用其它组件处理用户的请求,DispatcherServlet的存在降低了组件之间的耦合性。 处理器映射器HandlerMapping(不需要工程师开发),由框架提供作用:根据请求的url查找Handler。HandlerMapping负责根据用户请求找到Handler即处理器(Controller),SpringMVC提供了不同的映射器实现不同的映射方式。例如:配置文件方式,实现接口方式,注解方式等。 处理器适配器HandlerAdapter作用:按照特定规则(HandlerAdapter要求的规则)去执行Handler通过HandlerAdapter对处理器进行执行,这是适配器模式的应用,通过扩展适配器可以对更多类型的处理器进行执行。 处理器Handler(需要工程师开发)注意:编写Handler时按照HandlerAdapter的要求去做,这样适配器才可以去正确执行Handler,Handler是继DispatcherServlet前端控制器的后端控制器,在DispatcherServlet的控制下Handler对具体的用户请求进行处理。 由于Handler涉及到具体的用户业务请求,所以一般情况需要工程师根据业务需求开发Handler。 视图解析器View resolver(不需要工程师开发),由框架提供作用:进行视图解析,根据逻辑视图名解析成真正的视图(view)ViewResolver负责将处理结果生成View视图,ViewResolver首先根据逻辑视图名解析成物理视图名即具体的页面地址,再生成View视图对象,最后对View进行渲染将处理结果通过页面展示给用户。 springmvc框架提供了很多的View视图类型,包括:jstlView、freemarkerView、pdfView等。 一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户,需要由工程师根据业务需求开发具体的页面。 视图View(需要工程师开发)View是一个接口，实现类支持不同的View类型(jsp、freemarker、pdf…) 注意:处理器Handler(也就是我们平常说的Controller控制器)以及视图层view都是需要我们自己手动开发的。其他的一些组件比如:前端控制器DispatcherServlet、处理器映射器HandlerMapping、处理器适配器HandlerAdapter等等都是框架提供给我们的,不需要自己手动开发。 6.DispatcherServlet详细解析首先看下源码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package org.springframework.web.servlet;@SuppressWarnings(&quot;serial&quot;)public class DispatcherServlet extends FrameworkServlet { public static final String MULTIPART_RESOLVER_BEAN_NAME = &quot;multipartResolver&quot;; public static final String LOCALE_RESOLVER_BEAN_NAME = &quot;localeResolver&quot;; public static final String THEME_RESOLVER_BEAN_NAME = &quot;themeResolver&quot;; public static final String HANDLER_MAPPING_BEAN_NAME = &quot;handlerMapping&quot;; public static final String HANDLER_ADAPTER_BEAN_NAME = &quot;handlerAdapter&quot;; public static final String HANDLER_EXCEPTION_RESOLVER_BEAN_NAME = &quot;handlerExceptionResolver&quot;; public static final String REQUEST_TO_VIEW_NAME_TRANSLATOR_BEAN_NAME = &quot;viewNameTranslator&quot;; public static final String VIEW_RESOLVER_BEAN_NAME = &quot;viewResolver&quot;; public static final String FLASH_MAP_MANAGER_BEAN_NAME = &quot;flashMapManager&quot;; public static final String WEB_APPLICATION_CONTEXT_ATTRIBUTE = DispatcherServlet.class.getName() + &quot;.CONTEXT&quot;; public static final String LOCALE_RESOLVER_ATTRIBUTE = DispatcherServlet.class.getName() + &quot;.LOCALE_RESOLVER&quot;; public static final String THEME_RESOLVER_ATTRIBUTE = DispatcherServlet.class.getName() + &quot;.THEME_RESOLVER&quot;; public static final String THEME_SOURCE_ATTRIBUTE = DispatcherServlet.class.getName() + &quot;.THEME_SOURCE&quot;; public static final String INPUT_FLASH_MAP_ATTRIBUTE = DispatcherServlet.class.getName() + &quot;.INPUT_FLASH_MAP&quot;; public static final String OUTPUT_FLASH_MAP_ATTRIBUTE = DispatcherServlet.class.getName() + &quot;.OUTPUT_FLASH_MAP&quot;; public static final String FLASH_MAP_MANAGER_ATTRIBUTE = DispatcherServlet.class.getName() + &quot;.FLASH_MAP_MANAGER&quot;; public static final String EXCEPTION_ATTRIBUTE = DispatcherServlet.class.getName() + &quot;.EXCEPTION&quot;; public static final String PAGE_NOT_FOUND_LOG_CATEGORY = &quot;org.springframework.web.servlet.PageNotFound&quot;; private static final String DEFAULT_STRATEGIES_PATH = &quot;DispatcherServlet.properties&quot;; protected static final Log pageNotFoundLogger = LogFactory.getLog(PAGE_NOT_FOUND_LOG_CATEGORY); private static final Properties defaultStrategies; static { try { ClassPathResource resource = new ClassPathResource(DEFAULT_STRATEGIES_PATH, DispatcherServlet.class); defaultStrategies = PropertiesLoaderUtils.loadProperties(resource); } catch (IOException ex) { throw new IllegalStateException(&quot;Could not load 'DispatcherServlet.properties': &quot; + ex.getMessage()); } } /** Detect all HandlerMappings or just expect &quot;handlerMapping&quot; bean? */ private boolean detectAllHandlerMappings = true; /** Detect all HandlerAdapters or just expect &quot;handlerAdapter&quot; bean? */ private boolean detectAllHandlerAdapters = true; /** Detect all HandlerExceptionResolvers or just expect &quot;handlerExceptionResolver&quot; bean? */ private boolean detectAllHandlerExceptionResolvers = true; /** Detect all ViewResolvers or just expect &quot;viewResolver&quot; bean? */ private boolean detectAllViewResolvers = true; /** Throw a NoHandlerFoundException if no Handler was found to process this request? **/ private boolean throwExceptionIfNoHandlerFound = false; /** Perform cleanup of request attributes after include request? */ private boolean cleanupAfterInclude = true; /** MultipartResolver used by this servlet */ private MultipartResolver multipartResolver; /** LocaleResolver used by this servlet */ private LocaleResolver localeResolver; /** ThemeResolver used by this servlet */ private ThemeResolver themeResolver; /** List of HandlerMappings used by this servlet */ private List&lt;HandlerMapping&gt; handlerMappings; /** List of HandlerAdapters used by this servlet */ private List&lt;HandlerAdapter&gt; handlerAdapters; /** List of HandlerExceptionResolvers used by this servlet */ private List&lt;HandlerExceptionResolver&gt; handlerExceptionResolvers; /** RequestToViewNameTranslator used by this servlet */ private RequestToViewNameTranslator viewNameTranslator; private FlashMapManager flashMapManager; /** List of ViewResolvers used by this servlet */ private List&lt;ViewResolver&gt; viewResolvers; public DispatcherServlet() { super(); } public DispatcherServlet(WebApplicationContext webApplicationContext) { super(webApplicationContext); } @Override protected void onRefresh(ApplicationContext context) { initStrategies(context); } protected void initStrategies(ApplicationContext context) { initMultipartResolver(context); initLocaleResolver(context); initThemeResolver(context); initHandlerMappings(context); initHandlerAdapters(context); initHandlerExceptionResolvers(context); initRequestToViewNameTranslator(context); initViewResolvers(context); initFlashMapManager(context); }} DispatcherServlet类中的属性beans: HandlerMapping：用于handlers映射请求和一系列的对于拦截器的前处理和后处理，大部分用@Controller注解。 HandlerAdapter：帮助DispatcherServlet处理映射请求处理程序的适配器，而不用考虑实际调用的是 哪个处理程序。 ViewResolver：根据实际配置解析实际的View类型。 ThemeResolver：解决Web应用程序可以使用的主题，例如提供个性化布局。 MultipartResolver：解析多部分请求，以支持从HTML表单上传文件。 FlashMapManager：存储并检索可用于将一个请求属性传递到另一个请求的input和output的FlashMap，通常用于重定向。 &emsp;&emsp;在Web MVC框架中，每个DispatcherServlet都拥自己的WebApplicationContext，它继承了ApplicationContext。WebApplicationContext包含了其上下文和Servlet实例之间共享的所有的基础框架beans。 HandlerMapping HandlerMapping接口处理请求的映射HandlerMapping接口的实现类: SimpleUrlHandlerMapping类通过配置文件把URL映射到Controller类。 DefaultAnnotationHandlerMapping类通过注解把URL映射到Controller类。 HandlerAdapter HandlerAdapter接口-处理请求映射 AnnotationMethodHandlerAdapter：通过注解，把请求URL映射到Controller类的方法上。 HandlerExceptionResolver HandlerExceptionResolver接口-异常处理接口 SimpleMappingExceptionResolver通过配置文件进行异常处理。 AnnotationMethodHandlerExceptionResolver：通过注解进行异常处理。 ViewResolver ViewResolver接口解析View视图。UrlBasedViewResolver类 通过配置文件，把一个视图名交给到一个View来处理。","link":"/2020/02/16/springmvc/"},{"title":"搭建FTP服务器记录","text":"1.为了实现文件上传搭建FTP服务器，nginx做文件访问2.centos7环境下安装vsftpd&emsp;&emsp;vsftpd是linux下的一款小巧轻快，安全易用的FTP服务器软件，是一款在各个Linux发行版中最受推崇的FTP服务器软件。 1yum install -y vsftpd 3.vsftpd配置文件所在目录 4.配置文件 123456#访问黑名单ftpusers#访问白名单user_list#核心配置文件vsftpd.conf 5.常用命令 systemctl start vsftpd.service //启动ftp服务 systemctl enable vsftpd.service //设置开机自启动 netstat -antup | grep ftp //查看ftp服务端口 systemctl restart vsftpd.service //重启ftp服务 systemctl status vsftpd.service //查看ftp服务状态 6.windows环境ftp工具推荐(FileZilla Client) 7.vsftpd.conf配置文件说明 匿名用户默认情况下不允许创建目录和上传文件 为了安全性，关闭匿名登录，启用本地登录，创建新的linux用户专门用于ftp服务器 8.使用java代码上传文件到ftp服务器(这里的案例是先上传到tomcat运行目录，然后再从网络中读取图片到ftp服务器) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323@Componentpublic class FTPUtil { private static final Logger logger = LoggerFactory.getLogger(FTPUtil.class); private String host; private Integer port; private String username; private String password; private FTPClient ftpClient; /** * 1.连接ftp服务器 * 这里没有传递参数，调用无参构造方法使用默认ftp服务器配置 * * @return */ private boolean connect() { //连接结果 boolean connectResult = false; ftpClient = new FTPClient(); ftpClient.setControlEncoding(&quot;utf-8&quot;); try { System.out.println(&quot;开始连接FTP服务器！&quot; + host + &quot;:&quot; + port); ftpClient.connect(host, port); connectResult = ftpClient.login(username, password); System.out.println(&quot;连接FTP服务器成功！&quot; + host + &quot;:&quot; + port); } catch (IOException e) { logger.error(&quot;连接FTP服务器异常！&quot; + host + &quot;:&quot; + port, e); } return connectResult; } /** * 有参方法连接ftp服务器 * * @param host * @param port * @param username * @param password * @return */ private boolean connect(String host, Integer port, String username, String password) { //连接结果 boolean connectResult = false; ftpClient = new FTPClient(); ftpClient.setControlEncoding(&quot;utf-8&quot;); try { System.out.println(&quot;开始连接FTP服务器！&quot; + host + &quot;:&quot; + port); ftpClient.connect(host, port); connectResult = ftpClient.login(username, password); System.out.println(&quot;连接FTP服务器成功！&quot; + host + &quot;:&quot; + port); } catch (IOException e) { logger.error(&quot;连接FTP服务器异常！&quot; + host + &quot;:&quot; + port, e); } return connectResult; } /** * 2.上传文件 * * @param path 保存路径 * @param filename 文件名称 * @param originFilename 待上传文件的绝对地址 * @return */ public boolean uploadFile(String path, String filename,String originFilename) { InputStream inputStream = null; try { System.out.println(&quot;开始上传文件！&quot;); inputStream = getInputStreamFromURL(originFilename); //连接FTP服务器 connect(); ftpClient.setFileType(FTP.BINARY_FILE_TYPE); ftpClient.setControlEncoding(&quot;UTF-8&quot;); //在服务器创建目录 createDirectory(path); ftpClient.makeDirectory(path); ftpClient.changeWorkingDirectory(path); //传输模式设置为被动模式 ftpClient.enterLocalPassiveMode(); ftpClient.setFileTransferMode(FTP.STREAM_TRANSFER_MODE); //将inputStream写入ftp服务器 boolean storeFlag = ftpClient.storeFile(filename, inputStream); System.out.println(&quot;将inputStream写入ftp服务器的结果为：&quot; + storeFlag); inputStream.close(); ftpClient.logout(); System.out.println(&quot;文件上传成功！&quot;); } catch (Exception e) { System.out.println(&quot;文件上传失败！&quot;); logger.error(&quot;出现异常！&quot; + e); } finally { //不管文件上传结果都需要将ftpClient断开连接 if (ftpClient.isConnected()){ try { ftpClient.disconnect(); } catch (IOException e) { logger.error(&quot;出现异常！&quot; + e); } } //如果在try代码块内的inputStream.close()执行之前出现异常，finally代码块中做出判断并关闭 if (inputStream != null){ try { inputStream.close(); } catch (IOException e) { logger.error(&quot;出现异常！&quot; + e); } } } return true; } /** * * @param path 文件上传地址 * @param fileName 文件名称 * @param inputStream 输入流 * @return */ public boolean uploadFile(String path, String fileName, InputStream inputStream) { try { System.out.println(&quot;开始上传文件&quot;); //连接FTP服务器 connect(); ftpClient.setFileType(FTP.BINARY_FILE_TYPE); createDirectory(path); ftpClient.makeDirectory(path); ftpClient.changeWorkingDirectory(path); ftpClient.storeFile(fileName, inputStream); inputStream.close(); ftpClient.logout(); System.out.println(&quot;上传文件成功&quot;); } catch (Exception e) { System.out.println(&quot;上传文件失败&quot;); e.printStackTrace(); } finally { //不管文件上传结果都需要将ftpClient断开连接 if (ftpClient.isConnected()) { try { ftpClient.disconnect(); } catch (IOException e) { logger.error(&quot;出现异常！&quot; + e); } } //如果在try代码块内的inputStream.close()执行之前出现异常，finally代码块中做出判断并关闭 if (inputStream != null) { try { inputStream.close(); } catch (IOException e) { logger.error(&quot;出现异常！&quot; + e); } } } return true; } /** * 从URL中读取图片,转换成流形式. * @param destUrl * @return */ public static InputStream getInputStreamFromURL(String destUrl){ HttpURLConnection httpUrl = null; URL url = null; InputStream in = null; try{ url = new URL(destUrl); httpUrl = (HttpURLConnection) url.openConnection(); httpUrl.connect(); in = httpUrl.getInputStream(); return in; }catch (Exception e) { e.printStackTrace(); } return null; } /** * ftp * 创建多层目录文件，如果有ftp服务器已存在该文件，则不创建，如果无，则创建 * * @param remote * @throws IOException */ public void createDirectory(String remote) throws IOException { String directory = remote; String[] folder = new String[directory.split(&quot;/&quot;).length]; for (int i = 1; i &lt; directory.split(&quot;/&quot;).length ; i++) { folder[i] = directory.split(&quot;/&quot;)[i]; if (!changeWorkingDirectory(folder[i])){ makeDirectory(folder[i]); changeWorkingDirectory(folder[i]); } } } /** * 判断ftp服务器文件是否存在 * * @param path * @return * @throws IOException */ public boolean existFile(String path) throws IOException { boolean flag = false; FTPFile[] ftpFileArr = ftpClient.listFiles(path); if (ftpFileArr.length &gt; 15) { flag = true; } return flag; } /** * 创建目录 * * @param dir * @return */ public boolean makeDirectory(String dir) { boolean flag = true; try { flag = ftpClient.makeDirectory(dir); if (flag) { System.out.println(&quot;创建文件夹&quot; + dir + &quot; 成功！&quot;); } else { System.out.println(&quot;创建文件夹&quot; + dir + &quot; 失败！&quot;); } } catch (Exception e) { logger.error(&quot;创建文件夹出现异常！&quot;, e); } return flag; } /** * 改变目录路径 * * @param directory * @return */ public boolean changeWorkingDirectory(String directory) { boolean flag = true; if (directory.length() &gt; 10){ return false; }else { try { flag = ftpClient.changeWorkingDirectory(directory); if (flag) { System.out.println(&quot;进入文件夹&quot; + directory + &quot; 成功！&quot;); } else { System.out.println(&quot;进入文件夹&quot; + directory + &quot; 失败！开始创建文件夹&quot;); } } catch (IOException e) { logger.error(&quot;出现异常！&quot; + e); } } return flag; } /** * 调用无参构造方法默认连接的ftp服务器 */ public FTPUtil() { this.host = &quot;47.97.220.152&quot;; this.port = 21; this.username = &quot;ftptest&quot;; this.password = &quot;mili1228&quot;; } /** * 有参构造方法，自定义ftp服务器 * * @param host * @param port * @param username * @param password * @param ftpClient */ public FTPUtil(String host, Integer port, String username, String password, FTPClient ftpClient) { this.host = host; this.port = port; this.username = username; this.password = password; this.ftpClient = ftpClient; }}@RestControllerpublic class UploadUtil { SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy/MM/dd&quot;); @PostMapping(&quot;/upload/image&quot;) public RespBean uploadImg(@RequestParam(&quot;file&quot;) MultipartFile file,HttpServletRequest request) throws IOException { String format = simpleDateFormat.format(new Date()); String tmpPath = request.getSession().getServletContext().getRealPath(&quot;/uploadFile/images/&quot;); File folder = new File(tmpPath + format); if (!folder.isDirectory()){ folder.mkdirs(); } String path = (&quot;/uploadFile/images/&quot; + format); String oldName = file.getOriginalFilename(); String filename = UUID.randomUUID().toString() + oldName.substring(oldName.indexOf(&quot;.&quot;)); try { file.transferTo(new File(folder,filename)); } catch (IOException e) { e.printStackTrace(); } catch (IllegalStateException e) { e.printStackTrace(); } String originFilename = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + &quot;/uploadFile/images/&quot; + format + &quot;/&quot;+ filename; FTPUtil ftpUtil = new FTPUtil(); System.out.println(originFilename); boolean result = ftpUtil.uploadFile(path,filename,originFilename); if (result) { return RespBean.ok(&quot;文件上传成功！&quot;); } return RespBean.error(&quot;文件上传失败！&quot;); }}","link":"/2020/02/25/ftp/"},{"title":"Spring IOC","text":"原文地址 江南一点雨-spring教程 1.IOC概念 Ioc(Inversion of Control)，中文叫做控制反转。这是一个概念，也是一种思想。控制反转，实际上就是指对一个对象的控制权的反转。如果一个对象的控制权在另一个对象里面，对象间就会高度耦合。如果需要在另一个对象当中用到该对象，就得重新创建对象。对象的创建、初始化、销毁等工作就得由开发者自己完成，将这些操作交给Spring容器来管理就可以变得十分轻松。 使用Spring之后，项目启动时，所有的bean都将自己注册到Spring容器中去(如果有必要的话)，其他bean如果需要使用到另一个bean只需要去Spring容器里要。 2.IOC初体验 创建普通maven项目，引入spring-context依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt;&lt;/dependency&gt; 创建两个普通的bean 123456789101112131415161718public class Book { private Integer id; private String name; private Double price; //省略getter/setter //显示指定无参构造方法，打印日志 public Book() { System.out.println(&quot;Book无参构造方法执行！&quot;); } //省略toString方法}public class Author { private Integer id; private String name; private Integer age; //省略getter/setter} 在resources目录下创建一个spring的配置文件springConfig.xml(先引入依赖才有配置文件模板选项) 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--class属性表示需要注册的bean的全路径，id属性表示bean的唯一标记，也可以name属性作为bean的唯一标记--&gt; &lt;bean class=&quot;com.zlgwzy.Book&quot; id=&quot;book&quot;/&gt; &lt;bean class=&quot;com.zlgwzy.Author&quot; id=&quot;author&quot;/&gt;&lt;/beans&gt; 在Main方法里面加载配置文件，获取bean并打印bean 12345678public class Main { public static void main(String[] args) { //加载配置文件,加载方式，除了ClassPathXmlApplicationContext 之外（去 classpath 下查找配置文件），另外也可以使用 FileSystemXmlApplicationContext ，FileSystemXmlApplicationContext 会从操作系统路径下去寻找配置文件。 ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;springConfig.xml&quot;); Book book = (Book) context.getBean(&quot;book&quot;); System.out.println(book); }} 3.bean的获取 通过bean的id或者name属性获取 直接通过class获取bean,如果在配置文件中存在一个bean的多个实例就会抛异常(NoUniqueBeanDefinitionException),一般建议通过id或name属性去获取bean实例 4.属性的注入给Book添加构造方法 12345public Book(Integer id, String name, Double price) { this.id = id; this.name = name; this.price = price;} xml中注入bean，可以通过name或者index注入.如果有多个构造方法，则会根据给出参数个数以及参数类型，自动匹配到对应的构造方法上，进而初始化一个对象。 构造方法注入12345678910&lt;bean class=&quot;com.zlgwzy.Book&quot; id=&quot;book3&quot;&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;3&quot;/&gt; &lt;constructor-arg index=&quot;1&quot; value=&quot;图解HTTP&quot;/&gt; &lt;constructor-arg index=&quot;2&quot; value=&quot;35.00&quot;/&gt;&lt;/bean&gt;&lt;bean class=&quot;com.zlgwzy.Book&quot; id=&quot;book4&quot;&gt; &lt;constructor-arg name=&quot;id&quot; value=&quot;4&quot;/&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;图解TCP/IP&quot;/&gt; &lt;constructor-arg name=&quot;price&quot; value=&quot;35.00&quot;/&gt;&lt;/bean&gt; set方法注入&emsp;&emsp;在所有的框架中，凡是涉及到反射注入值的，属性名统统都不是 Bean 中定义的属性名，而是通过 Java 中的内省机制分析出来的属性名，简单说，就是根据 get/set 方法分析出来的属性名。12345678Book book1 = (Book) context.getBean(&quot;book1&quot;);book1.setId(1);book1.setName(&quot;算法(第四版)&quot;);book1.setPrice(45.00);Book book2 = (Book) context.getBean(&quot;book2&quot;);book2.setId(2);book2.setName(&quot;SpringBoot+Vue全栈开发实战&quot;);book2.setPrice(69.00); p名称空间注入，本质也调用了set方法1&lt;bean class=&quot;com.zlgwzy.Book&quot; id=&quot;book5&quot; p:id=&quot;5&quot; p:name=&quot;Vue项目实战&quot; p:price=&quot;45.00&quot;/&gt; 外部bean的注入&emsp;&emsp;有时候，我们使用一些外部 Bean，这些 Bean 可能没有构造方法，而是通过 Builder 来构造的，这个时候，就无法使用上面的方式来给它注入值了。&emsp;&emsp;例如在 OkHttp 的网络请求中，原生的写法如下:123456789101112131415161718192021222324252627282930public class OkHttpMain { public static void main(String[] args) { OkHttpClient okHttpClient = new OkHttpClient.Builder() .build(); Request request = new Request.Builder() .get() .url(&quot;http://b.hiphotos.baidu.com/image/h%3D300/sign=ad628627aacc7cd9e52d32d909032104/32fa828ba61ea8d3fcd2e9ce9e0a304e241f5803.jpg&quot;) .build(); Call call = okHttpClient.newCall(request); call.enqueue(new Callback() { @Override public void onFailure(@NotNull Call call, @NotNull IOException e) { System.out.println(e.getMessage()); } @Override public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException { FileOutputStream out = new FileOutputStream(new File(&quot;E:\\\\123.jpg&quot;)); int len; byte[] buf = new byte[1024]; InputStream is = response.body().byteStream(); while ((len = is.read(buf)) != -1) { out.write(buf, 0, len); } out.close(); is.close(); } }); }} &emsp;&emsp;这个 Bean 有一个特点，OkHttpClient 和 Request 两个实例都不是直接 new 出来的，在调用 Builder 方法的过程中，都会给它配置一些默认的参数。这种情况，我们可以使用 静态工厂注入或者实例工厂注入来给 OkHttpClient 提供一个实例。 静态工厂注入首先提供一个 OkHttpClient 的静态工厂:12345678910 public class OkHttpUtils { //工厂类为静态 private static OkHttpClient OkHttpClient; public static OkHttpClient getInstance() { if (OkHttpClient == null) { OkHttpClient = new OkHttpClient.Builder().build(); } return OkHttpClient; }} 在 xml 文件中，配置该静态工厂：1&lt;bean class=&quot;org.javaboy.OkHttpUtils&quot; factory-method=&quot;getInstance&quot; id=&quot;okHttpClient&quot;&gt;&lt;/bean&gt; 这个配置表示 OkHttpUtils 类中的 getInstance 是我们需要的实例，实例的名字就叫 okHttpClient。然后，在 Java 代码中，获取到这个实例，就可以直接使用了。123456789101112131415161718192021222324252627282930public class OkHttpMain { public static void main(String[] args) { ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); OkHttpClient okHttpClient = ctx.getBean(&quot;okHttpClient&quot;, OkHttpClient.class); Request request = new Request.Builder() .get() .url(&quot;http://b.hiphotos.baidu.com/image/h%3D300/sign=ad628627aacc7cd9e52d32d909032104/32fa828ba61ea8d3fcd2e9ce9e0a304e241f5803.jpg&quot;) .build(); Call call = okHttpClient.newCall(request); call.enqueue(new Callback() { @Override public void onFailure(@NotNull Call call, @NotNull IOException e) { System.out.println(e.getMessage()); } @Override public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException { FileOutputStream out = new FileOutputStream(new File(&quot;E:\\\\123.jpg&quot;)); int len; byte[] buf = new byte[1024]; InputStream is = response.body().byteStream(); while ((len = is.read(buf)) != -1) { out.write(buf, 0, len); } out.close(); is.close(); } }); }} 实例工厂注入&emsp;&emsp;实例工厂就是工厂方法是一个实例方法，这样，工厂类必须实例化之后才可以调用工厂方法。&emsp;&emsp;这次的工厂类:12345678910public class OkHttpUtils { //工厂类必须先实例化 private OkHttpClient OkHttpClient; public OkHttpClient getInstance() { if (OkHttpClient == null) { OkHttpClient = new OkHttpClient.Builder().build(); } return OkHttpClient; }} &emsp;&emsp;此时，在 xml 文件中，需要首先提供工厂方法的实例，然后才可以调用工厂方法：12&lt;bean class=&quot;com.zlgwzy.OkHttpUtils&quot; id=&quot;okHttpUtils&quot;/&gt;&lt;bean class=&quot;okhttp3.OkHttpClient&quot; factory-bean=&quot;okHttpUtils&quot; factory-method=&quot;getInstance&quot; id=&quot;okHttpClient&quot;&gt;&lt;/bean&gt; &emsp;&emsp;自己写的 Bean 一般不会使用这两种方式注入，但是，如果需要引入外部 jar，外部 jar 的类的初始化，有可能需要使用这两种方式。 5.复杂属性的注入 对象注入 1234567891011121314151617181920 //定义一个user对象public class User { private Book book; private String[] favoritesSport; private List&lt;Book&gt; favoritesBooks; private Map&lt;Integer,String&gt; map; private Properties info; //省略toString和get/set方法} //通过xml注入对象，通过ref引入一个对象 &lt;bean class=&quot;com.zlgwzy.User&quot; id=&quot;user&quot;&gt; &lt;property name=&quot;book&quot; ref=&quot;book6&quot;/&gt; &lt;/bean&gt; &lt;bean class=&quot;com.zlgwzy.Book&quot; id=&quot;book6&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;6&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;三国演义&quot;/&gt; &lt;property name=&quot;price&quot; value=&quot;30.00&quot;/&gt; &lt;/bean&gt; 2.数组注入注意，即可以通过 ref 使用外部定义好的 Bean，也可以直接在 list 或者 array 节点中定义 bean 12345678910111213141516&lt;bean class=&quot;com.zlgwzy.User&quot; id=&quot;user&quot;&gt; &lt;property name=&quot;book&quot; ref=&quot;book6&quot;/&gt; &lt;property name=&quot;favoritesSport&quot;&gt; &lt;array&gt; &lt;value&gt;听歌&lt;/value&gt; &lt;value&gt;看电影&lt;/value&gt; &lt;value&gt;写代码&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=&quot;favoritesBooks&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;book1&quot;/&gt; &lt;ref bean=&quot;book2&quot;/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 3.Map注入 123456 &lt;property name=&quot;map&quot;&gt; &lt;map&gt; &lt;entry key=&quot;1&quot; value=&quot;第一项&quot;/&gt; &lt;entry key=&quot;2&quot; value=&quot;第二项&quot;/&gt; &lt;/map&gt;&lt;/property&gt; 4.Properties注入 123456&lt;property name=&quot;info&quot;&gt; &lt;props&gt; &lt;prop key=&quot;age&quot;&gt;23&lt;/prop&gt; &lt;prop key=&quot;name&quot;&gt;mili&lt;/prop&gt; &lt;/props&gt;&lt;/property&gt; 6.Java配置&emsp;&emsp;在 Spring 中，想要将一个 Bean 注册到 Spring 容器中，整体上来说，有三种不同的方式。 xml注入 Java配置(通过java代码将bean注册到spring容器) 自动化扫描&emsp;&emsp;Java 配置这种方式在 Spring Boot 出现之前，其实很少使用，自从有了 Spring Boot，Java 配置开发被广泛使用，因为在 Spring Boot 中，不使用一行 XML 配置。 例如有如下的bean:12345public class MachineBoot { public String boot(Integer id){ return id + &quot;号机启动成功！&quot;; }} 创建Java配置类代替xml文件1234567@Configurationpublic class JavaConfig { @Bean MachineBoot boot(){ return new MachineBoot(); }} main方法里面加载配置，获取bean，调用bean里面的方法(通过AnnotationConfigApplicationContext加载配置)123AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(JavaConfig.class);MachineBoot machineBoot = (MachineBoot) context.getBean(&quot;boot&quot;);System.out.println(machineBoot.boot(9)); bean的默认名称为方法名，也可以在@Bean注解的后面自定义bean名称 7.自动化配置 &emsp;&emsp;例如我有一个 UserService，我希望在自动化扫描时，这个类能够自动注册到 Spring 容器中去，那么可以给该类添加一个 @Service，作为一个标记。 &emsp;&emsp;和 @Service 注解功能类似的注解，一共有四个： @Component 用于其他组件 @Repository 用于Dao层 @Service 用于Service层 @Controller 用于Controlelr层 Java代码自动扫描，@ComponentScan配置自动扫描的包，自动将有注解的bean注册到spring容器(如果不指定扫描的包，默认扫描配置类所在的包以及子包下的bean) 除了按照包的位置扫描，也可以按照注解进行扫描 xml配置自动扫描1234567 //扫描包下的所有bean&lt;context:component-scan base-package=&quot;org.javaboy.javaconfig&quot;/&gt;//按照注解进行扫描&lt;context:component-scan base-package=&quot;org.javaboy.javaconfig&quot; use-default-filters=&quot;true&quot;&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;&lt;/context:component-scan&gt; 对象注入 @Autowired @Resources @Injected&emsp;&emsp;@Autowired 是根据类型去查找，然后赋值，这就有一个要求，这个类型只可以有一个对象，否则就会报错。@Resources 是根据名称去查找，默认情况下，定义的变量名，就是查找的名称，当然开发者也可以在 @Resources 注解中手动指定。所以，如果一个类存在多个实例，那么就应该使用 @Resources 去注入，如果非常使用 @Autowired，也是可以的，此时需要配合另外一个注解，@Qualifier，在 @Qualifier 中可以指定变量名，两个一起用（@Qualifier 和 @Autowired）就可以实现通过变量名查找到变量。 8.条件注解 定义显示文件夹目录的接口123public interface ShowCmd { String showCmd();} 然后，分别实现 Windows 下的实例和 Linux 下的实例：123456789101112public class WinShowCmd implements ShowCmd { @Override public String showCmd() { return &quot;dir&quot;; }}public class LinuxShowCmd implements ShowCmd { @Override public String showCmd() { return &quot;ls&quot;; }} 接下来，定义两个条件，一个是 Windows 下的条件，另一个是 Linux 下的条件。123456789101112public class WindowsCondition implements Condition { @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) { return context.getEnvironment().getProperty(&quot;os.name&quot;).toLowerCase().contains(&quot;windows&quot;); }}public class LinuxCondition implements Condition { @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) { return context.getEnvironment().getProperty(&quot;os.name&quot;).toLowerCase().contains(&quot;linux&quot;); }} 接下来，在定义 Bean 的时候，就可以去配置条件注解了。1234567891011121314@Configurationpublic class JavaConfig { @Bean(&quot;showCmd&quot;) @Conditional(WindowsCondition.class) ShowCmd winCmd() { return new WinShowCmd(); } @Bean(&quot;showCmd&quot;) @Conditional(LinuxCondition.class) ShowCmd linuxCmd() { return new LinuxShowCmd(); }} 这里，一定要给两个 Bean 取相同的名字，这样在调用时，才可以自动匹配。然后，给每一个 Bean 加上条件注解，当条件中的 matches 方法返回 true 的时候，这个 Bean 的定义就会生效。1234567public class JavaMain { public static void main(String[] args) { AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(JavaConfig.class); ShowCmd showCmd = (ShowCmd) ctx.getBean(&quot;showCmd&quot;); System.out.println(showCmd.showCmd()); }} 9.其它 bean的作用于，默认情况下在spring容器中获取到的bean为同一个bean1234567891011121314151617181920&lt;bean class=&quot;com.mili.User&quot; id=&quot;user&quot; scope=&quot;prototype&quot; /&gt;//Java配置中设置scope@Configurationpublic class JavaConfig { @Bean @Scope(&quot;prototype&quot;) SayHello sayHello() { return new SayHello(); }}//自动化扫描配置scope@Repository@Scope(&quot;prototype&quot;)public class UserDao { public String hello() { return &quot;userdao&quot;; }} &emsp;&emsp;通过在 XML 节点中，设置 scope 属性，我们可以调整默认的实例个数。scope 的值为 singleton（默认），表示这个 Bean 在 Spring 容器中，是以单例的形式存在，如果 scope 的值为 prototype，表示这个 Bean 在 Spring 容器中不是单例，多次获取将拿到多个不同的实例。 id和name的区别(name支持取多个，用逗号隔开) 混合配置(在Java配置当中引入xml配置)1234@Configuration@ImportResource(&quot;classpath:applicationContext.xml&quot;)public class JavaConfig {}","link":"/2020/02/17/ioc/"},{"title":"Spring IOC 容器源码分析(转载)","text":"原文地址 JavadoopSpring 最重要的概念是 IOC 和 AOP，本篇文章其实就是要带领大家来分析下 Spring 的 IOC 容器。既然大家平时都要用到 Spring，怎么可以不好好了解 Spring 呢？阅读本文并不能让你成为 Spring 专家，不过一定有助于大家理解 Spring 的很多概念，帮助大家排查应用中和 Spring 相关的一些问题。 本文采用的源码版本是 4.3.11.RELEASE，算是 5.0.x 前比较新的版本了。为了降低难度，本文所说的所有的内容都是基于 xml 的配置的方式，实际使用已经很少人这么做了，至少不是纯 xml 配置，不过从理解源码的角度来看用这种方式来说无疑是最合适的。 阅读建议：读者至少需要知道怎么配置 Spring，了解 Spring 中的各种概念，少部分内容我还假设读者使用过 SpringMVC。本文要说的 IOC 总体来说有两处地方最重要，一个是创建 Bean 容器，一个是初始化 Bean，如果读者觉得一次性看完本文压力有点大，那么可以按这个思路分两次消化。读者不一定对 Spring 容器的源码感兴趣，也许附录部分介绍的知识对读者有些许作用。 希望通过本文可以让读者不惧怕阅读 Spring 源码，也希望大家能反馈表述错误或不合理的地方。 引言先看下最基本的启动 Spring 容器的例子： 123public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:applicationfile.xml\");} 以上代码就可以利用配置文件来启动一个 Spring 容器了，请使用 maven 的小伙伴直接在 dependencies 中加上以下依赖即可，个人比较反对那些不知道要添加什么依赖，然后把 Spring 的所有相关的东西都加进来的方式。 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.11.RELEASE&lt;/version&gt;&lt;/dependency&gt; spring-context 会自动将 spring-core、spring-beans、spring-aop、spring-expression 这几个基础 jar 包带进来。 多说一句，很多开发者入门就直接接触的 SpringMVC，对 Spring 其实不是很了解，Spring 是渐进式的工具，并不具有很强的侵入性，它的模块也划分得很合理，即使你的应用不是 web 应用，或者之前完全没有使用到 Spring，而你就想用 Spring 的依赖注入这个功能，其实完全是可以的，它的引入不会对其他的组件产生冲突。 废话说完，我们继续。ApplicationContext context = new ClassPathXmlApplicationContext(...) 其实很好理解，从名字上就可以猜出一二，就是在 ClassPath 中寻找 xml 配置文件，根据 xml 文件内容来构建 ApplicationContext。当然，除了 ClassPathXmlApplicationContext 以外，我们也还有其他构建 ApplicationContext 的方案可供选择，我们先来看看大体的继承结构是怎么样的： 读者可以大致看一下类名，源码分析的时候不至于找不着看哪个类，因为 Spring 为了适应各种使用场景，提供的各个接口都可能有很多的实现类。对于我们来说，就是揪着一个完整的分支看完。 当然，读本文的时候读者也不必太担心，每个代码块分析的时候，我都会告诉读者我们在说哪个类第几行。 我们可以看到，ClassPathXmlApplicationContext 兜兜转转了好久才到 ApplicationContext 接口，同样的，我们也可以使用绿颜色的 FileSystemXmlApplicationContext 和 AnnotationConfigApplicationContext 这两个类。 1、FileSystemXmlApplicationContext 的构造函数需要一个 xml 配置文件在系统中的路径，其他和 ClassPathXmlApplicationContext 基本上一样。 2、AnnotationConfigApplicationContext 是基于注解来使用的，它不需要配置文件，采用 java 配置类和各种注解来配置，是比较简单的方式，也是大势所趋吧。 不过本文旨在帮助大家理解整个构建流程，所以决定使用 ClassPathXmlApplicationContext 进行分析。 我们先来一个简单的例子来看看怎么实例化 ApplicationContext。 首先，定义一个接口： 123public interface MessageService { String getMessage();} 定义接口实现类： 123456public class MessageServiceImpl implements MessageService { public String getMessage() { return \"hello world\"; }} 接下来，我们在 resources 目录新建一个配置文件，文件名随意，通常叫 application.xml 或 application-xxx.xml 就可以了： 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://www.springframework.org/schema/beans\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\" default-autowire=\"byName\"&gt; &lt;bean id=\"messageService\" class=\"com.javadoop.example.MessageServiceImpl\"/&gt;&lt;/beans&gt; 这样，我们就可以跑起来了： 12345678910111213public class App { public static void main(String[] args) { // 用我们的配置文件来启动一个 ApplicationContext ApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:application.xml\"); System.out.println(\"context 启动成功\"); // 从 context 中取出我们的 Bean，而不是用 new MessageServiceImpl() 这种方式 MessageService messageService = context.getBean(MessageService.class); // 这句将输出: hello world System.out.println(messageService.getMessage()); }} 以上例子很简单，不过也够引出本文的主题了，就是怎么样通过配置文件来启动 Spring 的 ApplicationContext ？也就是我们今天要分析的 IOC 的核心了。ApplicationContext 启动过程中，会负责创建实例 Bean，往各个 Bean 中注入依赖等。 BeanFactory 简介BeanFactory，从名字上也很好理解，生产 bean 的工厂，它负责生产和管理各个 bean 实例。 初学者可别以为我之前说那么多和 BeanFactory 无关，前面说的 ApplicationContext 其实就是一个 BeanFactory。我们来看下和 BeanFactory 接口相关的主要的继承结构： 我想，大家看完这个图以后，可能就不是很开心了。ApplicationContext 往下的继承结构前面一张图说过了，这里就不重复了。这张图呢，背下来肯定是不需要的，有几个重点和大家说明下就好。 ApplicationContext 继承了 ListableBeanFactory，这个 Listable 的意思就是，通过这个接口，我们可以获取多个 Bean，大家看源码会发现，最顶层 BeanFactory 接口的方法都是获取单个 Bean 的。 ApplicationContext 继承了 HierarchicalBeanFactory，Hierarchical 单词本身已经能说明问题了，也就是说我们可以在应用中起多个 BeanFactory，然后可以将各个 BeanFactory 设置为父子关系。 AutowireCapableBeanFactory 这个名字中的 Autowire 大家都非常熟悉，它就是用来自动装配 Bean 用的，但是仔细看上图，ApplicationContext 并没有继承它，不过不用担心，不使用继承，不代表不可以使用组合，如果你看到 ApplicationContext 接口定义中的最后一个方法 getAutowireCapableBeanFactory() 就知道了。 ConfigurableListableBeanFactory 也是一个特殊的接口，看图，特殊之处在于它继承了第二层所有的三个接口，而 ApplicationContext 没有。这点之后会用到。 请先不用花时间在其他的接口和类上，先理解我说的这几点就可以了。 然后，请读者打开编辑器，翻一下 BeanFactory、ListableBeanFactory、HierarchicalBeanFactory、AutowireCapableBeanFactory、ApplicationContext 这几个接口的代码，大概看一下各个接口中的方法，大家心里要有底，限于篇幅，我就不贴代码介绍了。 启动过程分析下面将会是冗长的代码分析，记住，一定要自己打开源码来看，不然纯看是很累的。 第一步，我们肯定要从 ClassPathXmlApplicationContext 的构造方法说起。 1234567891011121314151617181920public class ClassPathXmlApplicationContext extends AbstractXmlApplicationContext { private Resource[] configResources; // 如果已经有 ApplicationContext 并需要配置成父子关系，那么调用这个构造方法 public ClassPathXmlApplicationContext(ApplicationContext parent) { super(parent); } ... public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent) throws BeansException { super(parent); // 根据提供的路径，处理成配置文件数组(以分号、逗号、空格、tab、换行符分割) setConfigLocations(configLocations); if (refresh) { refresh(); // 核心方法 } } ...} 接下来，就是 refresh()，这里简单说下为什么是 refresh()，而不是 init() 这种名字的方法。因为 ApplicationContext 建立起来以后，其实我们是可以通过调用 refresh() 这个方法重建的，refresh() 会将原来的 ApplicationContext 销毁，然后再重新执行一次初始化操作。 往下看，refresh() 方法里面调用了那么多方法，就知道肯定不简单了，请读者先看个大概，细节之后会详细说。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778@Overridepublic void refresh() throws BeansException, IllegalStateException { // 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛 synchronized (this.startupShutdownMonitor) { // 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符 prepareRefresh(); // 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中， // 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了， // 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map) ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean // 这块待会会展开说 prepareBeanFactory(beanFactory); try { // 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口， // 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】 // 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化 // 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事 postProcessBeanFactory(beanFactory); // 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法 invokeBeanFactoryPostProcessors(beanFactory); // 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别 // 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization // 两个方法分别在 Bean 初始化之前和初始化之后得到执行。注意，到这里 Bean 还没初始化 registerBeanPostProcessors(beanFactory); // 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了 initMessageSource(); // 初始化当前 ApplicationContext 的事件广播器，这里也不展开了 initApplicationEventMulticaster(); // 从方法名就可以知道，典型的模板方法(钩子方法)， // 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前） onRefresh(); // 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过 registerListeners(); // 重点，重点，重点 // 初始化所有的 singleton beans //（lazy-init 的除外） finishBeanFactoryInitialization(beanFactory); // 最后，广播事件，ApplicationContext 初始化完成 finishRefresh(); } catch (BeansException ex) { if (logger.isWarnEnabled()) { logger.warn(\"Exception encountered during context initialization - \" + \"cancelling refresh attempt: \" + ex); } // Destroy already created singletons to avoid dangling resources. // 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源 destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // 把异常往外抛 throw ex; } finally { // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); } }} 下面，我们开始一步步来肢解这个 refresh() 方法。 创建 Bean 容器前的准备工作这个比较简单，直接看代码中的几个注释即可。 12345678910111213141516171819protected void prepareRefresh() { // 记录启动时间， // 将 active 属性设置为 true，closed 属性设置为 false，它们都是 AtomicBoolean 类型 this.startupDate = System.currentTimeMillis(); this.closed.set(false); this.active.set(true); if (logger.isInfoEnabled()) { logger.info(\"Refreshing \" + this); } // Initialize any placeholder property sources in the context environment initPropertySources(); // 校验 xml 配置文件 getEnvironment().validateRequiredProperties(); this.earlyApplicationEvents = new LinkedHashSet&lt;ApplicationEvent&gt;();} 创建 Bean 容器，加载并注册 Bean我们回到 refresh() 方法中的下一行 obtainFreshBeanFactory()。 注意，这个方法是全文最重要的部分之一，这里将会初始化 BeanFactory、加载 Bean、注册 Bean 等等。 当然，这步结束后，Bean 并没有完成初始化。这里指的是 Bean 实例并未在这一步生成。 // AbstractApplicationContext.java 1234567891011protected ConfigurableListableBeanFactory obtainFreshBeanFactory() { // 关闭旧的 BeanFactory (如果有)，创建新的 BeanFactory，加载 Bean 定义、注册 Bean 等等 refreshBeanFactory(); // 返回刚刚创建的 BeanFactory ConfigurableListableBeanFactory beanFactory = getBeanFactory(); if (logger.isDebugEnabled()) { logger.debug(\"Bean factory for \" + getDisplayName() + \": \" + beanFactory); } return beanFactory;} // AbstractRefreshableApplicationContext.java 120 1234567891011121314151617181920212223242526272829@Overrideprotected final void refreshBeanFactory() throws BeansException { // 如果 ApplicationContext 中已经加载过 BeanFactory 了，销毁所有 Bean，关闭 BeanFactory // 注意，应用中 BeanFactory 本来就是可以多个的，这里可不是说应用全局是否有 BeanFactory，而是当前 // ApplicationContext 是否有 BeanFactory if (hasBeanFactory()) { destroyBeans(); closeBeanFactory(); } try { // 初始化一个 DefaultListableBeanFactory，为什么用这个，我们马上说。 DefaultListableBeanFactory beanFactory = createBeanFactory(); // 用于 BeanFactory 的序列化，我想不部分人应该都用不到 beanFactory.setSerializationId(getId()); // 下面这两个方法很重要，别跟丢了，具体细节之后说 // 设置 BeanFactory 的两个配置属性：是否允许 Bean 覆盖、是否允许循环引用 customizeBeanFactory(beanFactory); // 加载 Bean 到 BeanFactory 中 loadBeanDefinitions(beanFactory); synchronized (this.beanFactoryMonitor) { this.beanFactory = beanFactory; } } catch (IOException ex) { throw new ApplicationContextException(\"I/O error parsing bean definition source for \" + getDisplayName(), ex); }} 看到这里的时候，我觉得读者就应该站在高处看 ApplicationContext 了，ApplicationContext 继承自 BeanFactory，但是它不应该被理解为 BeanFactory 的实现类，而是说其内部持有一个实例化的 BeanFactory（DefaultListableBeanFactory）。以后所有的 BeanFactory 相关的操作其实是委托给这个实例来处理的。 我们说说为什么选择实例化 DefaultListableBeanFactory ？前面我们说了有个很重要的接口 ConfigurableListableBeanFactory，它实现了 BeanFactory 下面一层的所有三个接口，我把之前的继承图再拿过来大家再仔细看一下： 我们可以看到 ConfigurableListableBeanFactory 只有一个实现类 DefaultListableBeanFactory，而且实现类 DefaultListableBeanFactory 还通过实现右边的 AbstractAutowireCapableBeanFactory 通吃了右路。所以结论就是，最底下这个家伙 DefaultListableBeanFactory 基本上是最牛的 BeanFactory 了，这也是为什么这边会使用这个类来实例化的原因。 如果你想要在程序运行的时候动态往 Spring IOC 容器注册新的 bean，就会使用到这个类。那我们怎么在运行时获得这个实例呢？ 之前我们说过 ApplicationContext 接口能获取到 AutowireCapableBeanFactory，就是最右上角那个，然后它向下转型就能得到 DefaultListableBeanFactory 了。 那怎么拿到 ApplicationContext 实例呢？如果你不会，说明你没用过 Spring。 在继续往下之前，我们需要先了解 BeanDefinition。我们说 BeanFactory 是 Bean 容器，那么 Bean 又是什么呢？ 这里的 BeanDefinition 就是我们所说的 Spring 的 Bean，我们自己定义的各个 Bean 其实会转换成一个个 BeanDefinition 存在于 Spring 的 BeanFactory 中。 所以，如果有人问你 Bean 是什么的时候，你要知道 Bean 在代码层面上可以简单认为是 BeanDefinition 的实例。 BeanDefinition 中保存了我们的 Bean 信息，比如这个 Bean 指向的是哪个类、是否是单例的、是否懒加载、这个 Bean 依赖了哪些 Bean 等等。 BeanDefinition 接口定义我们来看下 BeanDefinition 的接口定义： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public interface BeanDefinition extends AttributeAccessor, BeanMetadataElement { // 我们可以看到，默认只提供 sington 和 prototype 两种， // 很多读者可能知道还有 request, session, globalSession, application, websocket 这几种， // 不过，它们属于基于 web 的扩展。 String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON; String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE; // 比较不重要，直接跳过吧 int ROLE_APPLICATION = 0; int ROLE_SUPPORT = 1; int ROLE_INFRASTRUCTURE = 2; // 设置父 Bean，这里涉及到 bean 继承，不是 java 继承。请参见附录的详细介绍 // 一句话就是：继承父 Bean 的配置信息而已 void setParentName(String parentName); // 获取父 Bean String getParentName(); // 设置 Bean 的类名称，将来是要通过反射来生成实例的 void setBeanClassName(String beanClassName); // 获取 Bean 的类名称 String getBeanClassName(); // 设置 bean 的 scope void setScope(String scope); String getScope(); // 设置是否懒加载 void setLazyInit(boolean lazyInit); boolean isLazyInit(); // 设置该 Bean 依赖的所有的 Bean，注意，这里的依赖不是指属性依赖(如 @Autowire 标记的)， // 是 depends-on=\"\" 属性设置的值。 void setDependsOn(String... dependsOn); // 返回该 Bean 的所有依赖 String[] getDependsOn(); // 设置该 Bean 是否可以注入到其他 Bean 中，只对根据类型注入有效， // 如果根据名称注入，即使这边设置了 false，也是可以的 void setAutowireCandidate(boolean autowireCandidate); // 该 Bean 是否可以注入到其他 Bean 中 boolean isAutowireCandidate(); // 主要的。同一接口的多个实现，如果不指定名字的话，Spring 会优先选择设置 primary 为 true 的 bean void setPrimary(boolean primary); // 是否是 primary 的 boolean isPrimary(); // 如果该 Bean 采用工厂方法生成，指定工厂名称。对工厂不熟悉的读者，请参加附录 // 一句话就是：有些实例不是用反射生成的，而是用工厂模式生成的 void setFactoryBeanName(String factoryBeanName); // 获取工厂名称 String getFactoryBeanName(); // 指定工厂类中的 工厂方法名称 void setFactoryMethodName(String factoryMethodName); // 获取工厂类中的 工厂方法名称 String getFactoryMethodName(); // 构造器参数 ConstructorArgumentValues getConstructorArgumentValues(); // Bean 中的属性值，后面给 bean 注入属性值的时候会说到 MutablePropertyValues getPropertyValues(); // 是否 singleton boolean isSingleton(); // 是否 prototype boolean isPrototype(); // 如果这个 Bean 是被设置为 abstract，那么不能实例化， // 常用于作为 父bean 用于继承，其实也很少用...... boolean isAbstract(); int getRole(); String getDescription(); String getResourceDescription(); BeanDefinition getOriginatingBeanDefinition();} 这个 BeanDefinition 其实已经包含很多的信息了，暂时不清楚所有的方法对应什么东西没关系，希望看完本文后读者可以彻底搞清楚里面的所有东西。 这里接口虽然那么多，但是没有类似 getInstance() 这种方法来获取我们定义的类的实例，真正的我们定义的类生成的实例到哪里去了呢？别着急，这个要很后面才能讲到。 有了 BeanDefinition 的概念以后，我们再往下看 refreshBeanFactory() 方法中的剩余部分： 12customizeBeanFactory(beanFactory);loadBeanDefinitions(beanFactory); 虽然只有两个方法，但路还很长啊。。。 customizeBeanFactorycustomizeBeanFactory(beanFactory) 比较简单，就是配置是否允许 BeanDefinition 覆盖、是否允许循环引用。 12345678910protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) { if (this.allowBeanDefinitionOverriding != null) { // 是否允许 Bean 定义覆盖 beanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding); } if (this.allowCircularReferences != null) { // 是否允许 Bean 间的循环依赖 beanFactory.setAllowCircularReferences(this.allowCircularReferences); }} BeanDefinition 的覆盖问题可能会有开发者碰到这个坑，就是在配置文件中定义 bean 时使用了相同的 id 或 name，默认情况下，allowBeanDefinitionOverriding 属性为 null，如果在同一配置文件中重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。 循环引用也很好理解：A 依赖 B，而 B 依赖 A。或 A 依赖 B，B 依赖 C，而 C 依赖 A。 默认情况下，Spring 允许循环依赖，当然如果你在 A 的构造方法中依赖 B，在 B 的构造方法中依赖 A 是不行的。 至于这两个属性怎么配置？我在附录中进行了介绍，尤其对于覆盖问题，很多人都希望禁止出现 Bean 覆盖，可是 Spring 默认是不同文件的时候可以覆盖的。 之后的源码中还会出现这两个属性，读者有个印象就可以了，它们不是非常重要。 加载 Bean: loadBeanDefinitions接下来是最重要的 loadBeanDefinitions(beanFactory) 方法了，这个方法将根据配置，加载各个 Bean，然后放到 BeanFactory 中。 读取配置的操作在 XmlBeanDefinitionReader 中，其负责加载配置、解析。 // AbstractXmlApplicationContext.java 80 123456789101112131415161718/** 我们可以看到，此方法将通过一个 XmlBeanDefinitionReader 实例来加载各个 Bean。*/@Overrideprotected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException { // 给这个 BeanFactory 实例化一个 XmlBeanDefinitionReader XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); // Configure the bean definition reader with this context's // resource loading environment. beanDefinitionReader.setEnvironment(this.getEnvironment()); beanDefinitionReader.setResourceLoader(this); beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this)); // 初始化 BeanDefinitionReader，其实这个是提供给子类覆写的， // 我看了一下，没有类覆写这个方法，我们姑且当做不重要吧 initBeanDefinitionReader(beanDefinitionReader); // 重点来了，继续往下 loadBeanDefinitions(beanDefinitionReader);} 现在还在这个类中，接下来用刚刚初始化的 Reader 开始来加载 xml 配置，这块代码读者可以选择性跳过，不是很重要。也就是说，下面这个代码块，读者可以很轻松地略过。 // AbstractXmlApplicationContext.java 120 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException { Resource[] configResources = getConfigResources(); if (configResources != null) { // 往下看 reader.loadBeanDefinitions(configResources); } String[] configLocations = getConfigLocations(); if (configLocations != null) { // 2 reader.loadBeanDefinitions(configLocations); }}// 上面虽然有两个分支，不过第二个分支很快通过解析路径转换为 Resource 以后也会进到这里@Overridepublic int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException { Assert.notNull(resources, \"Resource array must not be null\"); int counter = 0; // 注意这里是个 for 循环，也就是每个文件是一个 resource for (Resource resource : resources) { // 继续往下看 counter += loadBeanDefinitions(resource); } // 最后返回 counter，表示总共加载了多少的 BeanDefinition return counter;}// XmlBeanDefinitionReader 303@Overridepublic int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException { return loadBeanDefinitions(new EncodedResource(resource));}// XmlBeanDefinitionReader 314public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException { Assert.notNull(encodedResource, \"EncodedResource must not be null\"); if (logger.isInfoEnabled()) { logger.info(\"Loading XML bean definitions from \" + encodedResource.getResource()); } // 用一个 ThreadLocal 来存放配置文件资源 Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get(); if (currentResources == null) { currentResources = new HashSet&lt;EncodedResource&gt;(4); this.resourcesCurrentlyBeingLoaded.set(currentResources); } if (!currentResources.add(encodedResource)) { throw new BeanDefinitionStoreException( \"Detected cyclic loading of \" + encodedResource + \" - check your import definitions!\"); } try { InputStream inputStream = encodedResource.getResource().getInputStream(); try { InputSource inputSource = new InputSource(inputStream); if (encodedResource.getEncoding() != null) { inputSource.setEncoding(encodedResource.getEncoding()); } // 核心部分是这里，往下面看 return doLoadBeanDefinitions(inputSource, encodedResource.getResource()); } finally { inputStream.close(); } } catch (IOException ex) { throw new BeanDefinitionStoreException( \"IOException parsing XML document from \" + encodedResource.getResource(), ex); } finally { currentResources.remove(encodedResource); if (currentResources.isEmpty()) { this.resourcesCurrentlyBeingLoaded.remove(); } }}// 还在这个文件中，第 388 行protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) throws BeanDefinitionStoreException { try { // 这里就不看了，将 xml 文件转换为 Document 对象 Document doc = doLoadDocument(inputSource, resource); // 继续 return registerBeanDefinitions(doc, resource); } catch (...}// 还在这个文件中，第 505 行// 返回值：返回从当前配置文件加载了多少数量的 Beanpublic int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException { BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); int countBefore = getRegistry().getBeanDefinitionCount(); // 这里 documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); return getRegistry().getBeanDefinitionCount() - countBefore;}// DefaultBeanDefinitionDocumentReader 90@Overridepublic void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) { this.readerContext = readerContext; logger.debug(\"Loading bean definitions\"); Element root = doc.getDocumentElement(); // 从 xml 根节点开始解析文件 doRegisterBeanDefinitions(root);} 经过漫长的链路，一个配置文件终于转换为一颗 DOM 树了，注意，这里指的是其中一个配置文件，不是所有的，读者可以看到上面有个 for 循环的。下面开始从根节点开始解析： doRegisterBeanDefinitions：123456789101112131415161718192021222324252627282930313233// DefaultBeanDefinitionDocumentReader 116protected void doRegisterBeanDefinitions(Element root) { // 我们看名字就知道，BeanDefinitionParserDelegate 必定是一个重要的类，它负责解析 Bean 定义， // 这里为什么要定义一个 parent? 看到后面就知道了，是递归问题， // 因为 &lt;beans /&gt; 内部是可以定义 &lt;beans /&gt; 的，所以这个方法的 root 其实不一定就是 xml 的根节点，也可以是嵌套在里面的 &lt;beans /&gt; 节点，从源码分析的角度，我们当做根节点就好了 BeanDefinitionParserDelegate parent = this.delegate; this.delegate = createDelegate(getReaderContext(), root, parent); if (this.delegate.isDefaultNamespace(root)) { // 这块说的是根节点 &lt;beans ... profile=\"dev\" /&gt; 中的 profile 是否是当前环境需要的， // 如果当前环境配置的 profile 不包含此 profile，那就直接 return 了，不对此 &lt;beans /&gt; 解析 // 不熟悉 profile 为何物，不熟悉怎么配置 profile 读者的请移步附录区 String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE); if (StringUtils.hasText(profileSpec)) { String[] specifiedProfiles = StringUtils.tokenizeToStringArray( profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS); if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) { if (logger.isInfoEnabled()) { logger.info(\"Skipped XML bean definition file due to specified profiles [\" + profileSpec + \"] not matching: \" + getReaderContext().getResource()); } return; } } } preProcessXml(root); // 钩子 // 往下看 parseBeanDefinitions(root, this.delegate); postProcessXml(root); // 钩子 this.delegate = parent;} preProcessXml(root) 和 postProcessXml(root) 是给子类用的钩子方法，鉴于没有被使用到，也不是我们的重点，我们直接跳过。 这里涉及到了 profile 的问题，对于不了解的读者，我在附录中对 profile 做了简单的解释，读者可以参考一下。 接下来，看核心解析方法 parseBeanDefinitions(root, this.delegate) : 123456789101112131415161718192021222324// default namespace 涉及到的就四个标签 &lt;import /&gt;、&lt;alias /&gt;、&lt;bean /&gt; 和 &lt;beans /&gt;，// 其他的属于 custom 的protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) { if (delegate.isDefaultNamespace(root)) { NodeList nl = root.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) { Node node = nl.item(i); if (node instanceof Element) { Element ele = (Element) node; if (delegate.isDefaultNamespace(ele)) { // 解析 default namespace 下面的几个元素 parseDefaultElement(ele, delegate); } else { // 解析其他 namespace 的元素 delegate.parseCustomElement(ele); } } } } else { delegate.parseCustomElement(root); }} 从上面的代码，我们可以看到，对于每个配置来说，分别进入到 parseDefaultElement(ele, delegate); 和 delegate.parseCustomElement(ele); 这两个分支了。 parseDefaultElement(ele, delegate) 代表解析的节点是 &lt;import /&gt;、&lt;alias /&gt;、&lt;bean /&gt;、&lt;beans /&gt; 这几个。 这里的四个标签之所以是 default 的，是因为它们是处于这个 namespace 下定义的： 1http://www.springframework.org/schema/beans 又到初学者科普时间，不熟悉 namespace 的读者请看下面贴出来的 xml，这里的第二行 xmlns 就是咯。 123456&lt;beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://www.springframework.org/schema/beans\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\" default-autowire=\"byName\"&gt; 而对于其他的标签，将进入到 delegate.parseCustomElement(element) 这个分支。如我们经常会使用到的 &lt;mvc /&gt;、&lt;task /&gt;、&lt;context /&gt;、&lt;aop /&gt;等。 这些属于扩展，如果需要使用上面这些 ”非 default“ 标签，那么上面的 xml 头部的地方也要引入相应的 namespace 和 .xsd 文件的路径，如下所示。同时代码中需要提供相应的 parser 来解析，如 MvcNamespaceHandler、TaskNamespaceHandler、ContextNamespaceHandler、AopNamespaceHandler 等。 假如读者想分析 &lt;context:property-placeholder location=&quot;classpath:xx.properties&quot; /&gt; 的实现原理，就应该到 ContextNamespaceHandler 中找答案。 12345678910111213&lt;beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd \" default-autowire=\"byName\"&gt; 同理，以后你要是碰到 &lt;dubbo /&gt; 这种标签，那么就应该搜一搜是不是有 DubboNamespaceHandler 这个处理类。 回过神来，看看处理 default 标签的方法： 12345678910111213141516171819private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) { if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) { // 处理 &lt;import /&gt; 标签 importBeanDefinitionResource(ele); } else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) { // 处理 &lt;alias /&gt; 标签定义 // &lt;alias name=\"fromName\" alias=\"toName\"/&gt; processAliasRegistration(ele); } else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) { // 处理 &lt;bean /&gt; 标签定义，这也算是我们的重点吧 processBeanDefinition(ele, delegate); } else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) { // 如果碰到的是嵌套的 &lt;beans /&gt; 标签，需要递归 doRegisterBeanDefinitions(ele); }} 如果每个标签都说，那我不吐血，你们都要吐血了。我们挑我们的重点 &lt;bean /&gt; 标签出来说。 processBeanDefinition 解析 bean 标签下面是 processBeanDefinition 解析 &lt;bean /&gt; 标签： // DefaultBeanDefinitionDocumentReader 298 1234567891011121314151617181920protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) { // 将 &lt;bean /&gt; 节点中的信息提取出来，然后封装到一个 BeanDefinitionHolder 中，细节往下看 BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); // 下面的几行先不要看，跳过先，跳过先，跳过先，后面会继续说的 if (bdHolder != null) { bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try { // Register the final decorated instance. BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); } catch (BeanDefinitionStoreException ex) { getReaderContext().error(\"Failed to register bean definition with name '\" + bdHolder.getBeanName() + \"'\", ele, ex); } // Send registration event. getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); }} 继续往下看怎么解析之前，我们先看下 &lt;bean /&gt; 标签中可以定义哪些属性： Property class 类的全限定名 name 可指定 id、name(用逗号、分号、空格分隔) scope 作用域 constructor arguments 指定构造参数 properties 设置属性的值 autowiring mode no(默认值)、byName、byType、 constructor lazy-initialization mode 是否懒加载(如果被非懒加载的bean依赖了那么其实也就不能懒加载了) initialization method bean 属性设置完成后，会调用这个方法 destruction method bean 销毁后的回调方法 上面表格中的内容我想大家都非常熟悉吧，如果不熟悉，那就是你不够了解 Spring 的配置了。 简单地说就是像下面这样子： 123456789101112131415&lt;bean id=\"exampleBean\" name=\"name1, name2, name3\" class=\"com.javadoop.ExampleBean\" scope=\"singleton\" lazy-init=\"true\" init-method=\"init\" destroy-method=\"cleanup\"&gt; &lt;!-- 可以用下面三种形式指定构造参数 --&gt; &lt;constructor-arg type=\"int\" value=\"7500000\"/&gt; &lt;constructor-arg name=\"years\" value=\"7500000\"/&gt; &lt;constructor-arg index=\"0\" value=\"7500000\"/&gt; &lt;!-- property 的几种情况 --&gt; &lt;property name=\"beanOne\"&gt; &lt;ref bean=\"anotherExampleBean\"/&gt; &lt;/property&gt; &lt;property name=\"beanTwo\" ref=\"yetAnotherBean\"/&gt; &lt;property name=\"integerProperty\" value=\"1\"/&gt;&lt;/bean&gt; 当然，除了上面举例出来的这些，还有 factory-bean、factory-method、&lt;lockup-method /&gt;、&lt;replaced-method /&gt;、&lt;meta /&gt;、&lt;qualifier /&gt; 这几个，大家是不是熟悉呢？自己检验一下自己对 Spring 中 bean 的了解程度。 有了以上这些知识以后，我们再继续往里看怎么解析 bean 元素，是怎么转换到 BeanDefinitionHolder 的。 // BeanDefinitionParserDelegate 428 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) { return parseBeanDefinitionElement(ele, null);}public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) { String id = ele.getAttribute(ID_ATTRIBUTE); String nameAttr = ele.getAttribute(NAME_ATTRIBUTE); List&lt;String&gt; aliases = new ArrayList&lt;String&gt;(); // 将 name 属性的定义按照 “逗号、分号、空格” 切分，形成一个 别名列表数组， // 当然，如果你不定义 name 属性的话，就是空的了 // 我在附录中简单介绍了一下 id 和 name 的配置，大家可以看一眼，有个20秒就可以了 if (StringUtils.hasLength(nameAttr)) { String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS); aliases.addAll(Arrays.asList(nameArr)); } String beanName = id; // 如果没有指定id, 那么用别名列表的第一个名字作为beanName if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) { beanName = aliases.remove(0); if (logger.isDebugEnabled()) { logger.debug(\"No XML 'id' specified - using '\" + beanName + \"' as bean name and \" + aliases + \" as aliases\"); } } if (containingBean == null) { checkNameUniqueness(beanName, aliases, ele); } // 根据 &lt;bean ...&gt;...&lt;/bean&gt; 中的配置创建 BeanDefinition，然后把配置中的信息都设置到实例中, // 细节后面细说，先知道下面这行结束后，一个 BeanDefinition 实例就出来了。 AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean); // 到这里，整个 &lt;bean /&gt; 标签就算解析结束了，一个 BeanDefinition 就形成了。 if (beanDefinition != null) { // 如果都没有设置 id 和 name，那么此时的 beanName 就会为 null，进入下面这块代码产生 // 如果读者不感兴趣的话，我觉得不需要关心这块代码，对本文源码分析来说，这些东西不重要 if (!StringUtils.hasText(beanName)) { try { if (containingBean != null) {// 按照我们的思路，这里 containingBean 是 null 的 beanName = BeanDefinitionReaderUtils.generateBeanName( beanDefinition, this.readerContext.getRegistry(), true); } else { // 如果我们不定义 id 和 name，那么我们引言里的那个例子： // 1. beanName 为：com.javadoop.example.MessageServiceImpl#0 // 2. beanClassName 为：com.javadoop.example.MessageServiceImpl beanName = this.readerContext.generateBeanName(beanDefinition); String beanClassName = beanDefinition.getBeanClassName(); if (beanClassName != null &amp;&amp; beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp; !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) { // 把 beanClassName 设置为 Bean 的别名 aliases.add(beanClassName); } } if (logger.isDebugEnabled()) { logger.debug(\"Neither XML 'id' nor 'name' specified - \" + \"using generated bean name [\" + beanName + \"]\"); } } catch (Exception ex) { error(ex.getMessage(), ele); return null; } } String[] aliasesArray = StringUtils.toStringArray(aliases); // 返回 BeanDefinitionHolder return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray); } return null;} 然后，我们再看看怎么根据配置创建 BeanDefinition 实例的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public AbstractBeanDefinition parseBeanDefinitionElement( Element ele, String beanName, BeanDefinition containingBean) { this.parseState.push(new BeanEntry(beanName)); String className = null; if (ele.hasAttribute(CLASS_ATTRIBUTE)) { className = ele.getAttribute(CLASS_ATTRIBUTE).trim(); } try { String parent = null; if (ele.hasAttribute(PARENT_ATTRIBUTE)) { parent = ele.getAttribute(PARENT_ATTRIBUTE); } // 创建 BeanDefinition，然后设置类信息而已，很简单，就不贴代码了 AbstractBeanDefinition bd = createBeanDefinition(className, parent); // 设置 BeanDefinition 的一堆属性，这些属性定义在 AbstractBeanDefinition 中 parseBeanDefinitionAttributes(ele, beanName, containingBean, bd); bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT)); /** * 下面的一堆是解析 &lt;bean&gt;......&lt;/bean&gt; 内部的子元素， * 解析出来以后的信息都放到 bd 的属性中 */ // 解析 &lt;meta /&gt; parseMetaElements(ele, bd); // 解析 &lt;lookup-method /&gt; parseLookupOverrideSubElements(ele, bd.getMethodOverrides()); // 解析 &lt;replaced-method /&gt; parseReplacedMethodSubElements(ele, bd.getMethodOverrides()); // 解析 &lt;constructor-arg /&gt; parseConstructorArgElements(ele, bd); // 解析 &lt;property /&gt; parsePropertyElements(ele, bd); // 解析 &lt;qualifier /&gt; parseQualifierElements(ele, bd); bd.setResource(this.readerContext.getResource()); bd.setSource(extractSource(ele)); return bd; } catch (ClassNotFoundException ex) { error(\"Bean class [\" + className + \"] not found\", ele, ex); } catch (NoClassDefFoundError err) { error(\"Class that bean class [\" + className + \"] depends on not found\", ele, err); } catch (Throwable ex) { error(\"Unexpected failure during bean definition parsing\", ele, ex); } finally { this.parseState.pop(); } return null;} 到这里，我们已经完成了根据 &lt;bean /&gt; 配置创建了一个 BeanDefinitionHolder 实例。注意，是一个。 我们回到解析 &lt;bean /&gt; 的入口方法: 123456789101112131415161718protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) { // 将 &lt;bean /&gt; 节点转换为 BeanDefinitionHolder，就是上面说的一堆 BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); if (bdHolder != null) { // 如果有自定义属性的话，进行相应的解析，先忽略 bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try { // 我们把这步叫做 注册Bean 吧 BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); } catch (BeanDefinitionStoreException ex) { getReaderContext().error(\"Failed to register bean definition with name '\" + bdHolder.getBeanName() + \"'\", ele, ex); } // 注册完成后，发送事件，本文不展开说这个 getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); }} 大家再仔细看一下这块吧，我们后面就不回来说这个了。这里已经根据一个 &lt;bean /&gt; 标签产生了一个 BeanDefinitionHolder 的实例，这个实例里面也就是一个 BeanDefinition 的实例和它的 beanName、aliases 这三个信息，注意，我们的关注点始终在 BeanDefinition 上： 12345678public class BeanDefinitionHolder implements BeanMetadataElement { private final BeanDefinition beanDefinition; private final String beanName; private final String[] aliases;... 然后我们准备注册这个 BeanDefinition，最后，把这个注册事件发送出去。 下面，我们开始说说注册 Bean 吧。 注册 Bean// BeanDefinitionReaderUtils 143 123456789101112131415161718public static void registerBeanDefinition( BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) throws BeanDefinitionStoreException { String beanName = definitionHolder.getBeanName(); // 注册这个 Bean registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition()); // 如果还有别名的话，也要根据别名全部注册一遍，不然根据别名就会找不到 Bean 了 String[] aliases = definitionHolder.getAliases(); if (aliases != null) { for (String alias : aliases) { // alias -&gt; beanName 保存它们的别名信息，这个很简单，用一个 map 保存一下就可以了， // 获取的时候，会先将 alias 转换为 beanName，然后再查找 registry.registerAlias(beanName, alias); } }} 别名注册的放一边，毕竟它很简单，我们看看怎么注册 Bean。 // DefaultListableBeanFactory 793 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182@Overridepublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException { Assert.hasText(beanName, \"Bean name must not be empty\"); Assert.notNull(beanDefinition, \"BeanDefinition must not be null\"); if (beanDefinition instanceof AbstractBeanDefinition) { try { ((AbstractBeanDefinition) beanDefinition).validate(); } catch (BeanDefinitionValidationException ex) { throw new BeanDefinitionStoreException(...); } } // old? 还记得 “允许 bean 覆盖” 这个配置吗？allowBeanDefinitionOverriding BeanDefinition oldBeanDefinition; // 之后会看到，所有的 Bean 注册后会放入这个 beanDefinitionMap 中 oldBeanDefinition = this.beanDefinitionMap.get(beanName); // 处理重复名称的 Bean 定义的情况 if (oldBeanDefinition != null) { if (!isAllowBeanDefinitionOverriding()) { // 如果不允许覆盖的话，抛异常 throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription()... } else if (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) { // log...用框架定义的 Bean 覆盖用户自定义的 Bean } else if (!beanDefinition.equals(oldBeanDefinition)) { // log...用新的 Bean 覆盖旧的 Bean } else { // log...用同等的 Bean 覆盖旧的 Bean，这里指的是 equals 方法返回 true 的 Bean } // 覆盖 this.beanDefinitionMap.put(beanName, beanDefinition); } else { // 判断是否已经有其他的 Bean 开始初始化了. // 注意，\"注册Bean\" 这个动作结束，Bean 依然还没有初始化，我们后面会有大篇幅说初始化过程， // 在 Spring 容器启动的最后，会 预初始化 所有的 singleton beans if (hasBeanCreationStarted()) { // Cannot modify startup-time collection elements anymore (for stable iteration) synchronized (this.beanDefinitionMap) { this.beanDefinitionMap.put(beanName, beanDefinition); List&lt;String&gt; updatedDefinitions = new ArrayList&lt;String&gt;(this.beanDefinitionNames.size() + 1); updatedDefinitions.addAll(this.beanDefinitionNames); updatedDefinitions.add(beanName); this.beanDefinitionNames = updatedDefinitions; if (this.manualSingletonNames.contains(beanName)) { Set&lt;String&gt; updatedSingletons = new LinkedHashSet&lt;String&gt;(this.manualSingletonNames); updatedSingletons.remove(beanName); this.manualSingletonNames = updatedSingletons; } } } else { // 最正常的应该是进到这个分支。 // 将 BeanDefinition 放到这个 map 中，这个 map 保存了所有的 BeanDefinition this.beanDefinitionMap.put(beanName, beanDefinition); // 这是个 ArrayList，所以会按照 bean 配置的顺序保存每一个注册的 Bean 的名字 this.beanDefinitionNames.add(beanName); // 这是个 LinkedHashSet，代表的是手动注册的 singleton bean， // 注意这里是 remove 方法，到这里的 Bean 当然不是手动注册的 // 手动指的是通过调用以下方法注册的 bean ： // registerSingleton(String beanName, Object singletonObject) // 这不是重点，解释只是为了不让大家疑惑。Spring 会在后面\"手动\"注册一些 Bean， // 如 \"environment\"、\"systemProperties\" 等 bean，我们自己也可以在运行时注册 Bean 到容器中的 this.manualSingletonNames.remove(beanName); } // 这个不重要，在预初始化的时候会用到，不必管它。 this.frozenBeanDefinitionNames = null; } if (oldBeanDefinition != null || containsSingleton(beanName)) { resetBeanDefinition(beanName); }} 总结一下，到这里已经初始化了 Bean 容器，&lt;bean /&gt; 配置也相应的转换为了一个个 BeanDefinition，然后注册了各个 BeanDefinition 到注册中心，并且发送了注册事件。 ——— 分割线 ——— 到这里是一个分水岭，前面的内容都还算比较简单，不过应该也比较繁琐，大家要清楚地知道前面都做了哪些事情。 Bean 容器实例化完成后说到这里，我们回到 refresh() 方法，我重新贴了一遍代码，看看我们说到哪了。是的，我们才说完 obtainFreshBeanFactory() 方法。 考虑到篇幅，这里开始大幅缩减掉没必要详细介绍的部分，大家直接看下面的代码中的注释就好了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980@Overridepublic void refresh() throws BeansException, IllegalStateException { // 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛 synchronized (this.startupShutdownMonitor) { // 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符 prepareRefresh(); // 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中， // 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了， // 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map) ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean // 这块待会会展开说 prepareBeanFactory(beanFactory); try { // 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口， // 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】 // 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化 // 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事 postProcessBeanFactory(beanFactory); // 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 回调方法 invokeBeanFactoryPostProcessors(beanFactory); // 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别 // 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization // 两个方法分别在 Bean 初始化之前和初始化之后得到执行。这里仅仅是注册，之后会看到回调这两方法的时机 registerBeanPostProcessors(beanFactory); // 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了 initMessageSource(); // 初始化当前 ApplicationContext 的事件广播器，这里也不展开了 initApplicationEventMulticaster(); // 从方法名就可以知道，典型的模板方法(钩子方法)，不展开说 // 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前） onRefresh(); // 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过 registerListeners(); // 重点，重点，重点 // 初始化所有的 singleton beans //（lazy-init 的除外） finishBeanFactoryInitialization(beanFactory); // 最后，广播事件，ApplicationContext 初始化完成，不展开 finishRefresh(); } catch (BeansException ex) { if (logger.isWarnEnabled()) { logger.warn(\"Exception encountered during context initialization - \" + \"cancelling refresh attempt: \" + ex); } // Destroy already created singletons to avoid dangling resources. // 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源 destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // 把异常往外抛 throw ex; } finally { // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); } }} 准备 Bean 容器: prepareBeanFactory之前我们说过，Spring 把我们在 xml 配置的 bean 都注册以后，会”手动”注册一些特殊的 bean。 这里简单介绍下 prepareBeanFactory(factory) 方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * Configure the factory's standard context characteristics, * such as the context's ClassLoader and post-processors. * @param beanFactory the BeanFactory to configure */protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) { // 设置 BeanFactory 的类加载器，我们知道 BeanFactory 需要加载类，也就需要类加载器， // 这里设置为加载当前 ApplicationContext 类的类加载器 beanFactory.setBeanClassLoader(getClassLoader()); // 设置 BeanExpressionResolver beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader())); // beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment())); // 添加一个 BeanPostProcessor，这个 processor 比较简单： // 实现了 Aware 接口的 beans 在初始化的时候，这个 processor 负责回调， // 这个我们很常用，如我们会为了获取 ApplicationContext 而 implement ApplicationContextAware // 注意：它不仅仅回调 ApplicationContextAware， // 还会负责回调 EnvironmentAware、ResourceLoaderAware 等，看下源码就清楚了 beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this)); // 下面几行的意思就是，如果某个 bean 依赖于以下几个接口的实现类，在自动装配的时候忽略它们， // Spring 会通过其他方式来处理这些依赖。 beanFactory.ignoreDependencyInterface(EnvironmentAware.class); beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class); beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class); beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class); beanFactory.ignoreDependencyInterface(MessageSourceAware.class); beanFactory.ignoreDependencyInterface(ApplicationContextAware.class); /** * 下面几行就是为特殊的几个 bean 赋值，如果有 bean 依赖了以下几个，会注入这边相应的值， * 之前我们说过，\"当前 ApplicationContext 持有一个 BeanFactory\"，这里解释了第一行。 * ApplicationContext 还继承了 ResourceLoader、ApplicationEventPublisher、MessageSource * 所以对于这几个依赖，可以赋值为 this，注意 this 是一个 ApplicationContext * 那这里怎么没看到为 MessageSource 赋值呢？那是因为 MessageSource 被注册成为了一个普通的 bean */ beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory); beanFactory.registerResolvableDependency(ResourceLoader.class, this); beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this); beanFactory.registerResolvableDependency(ApplicationContext.class, this); // 这个 BeanPostProcessor 也很简单，在 bean 实例化后，如果是 ApplicationListener 的子类， // 那么将其添加到 listener 列表中，可以理解成：注册 事件监听器 beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this)); // 这里涉及到特殊的 bean，名为：loadTimeWeaver，这不是我们的重点，忽略它 // tips: ltw 是 AspectJ 的概念，指的是在运行期进行织入，这个和 Spring AOP 不一样， // 感兴趣的读者请参考我写的关于 AspectJ 的另一篇文章 https://www.javadoop.com/post/aspectj if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) { beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory)); // Set a temporary ClassLoader for type matching. beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader())); } /** * 从下面几行代码我们可以知道，Spring 往往很 \"智能\" 就是因为它会帮我们默认注册一些有用的 bean， * 我们也可以选择覆盖 */ // 如果没有定义 \"environment\" 这个 bean，那么 Spring 会 \"手动\" 注册一个 if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) { beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment()); } // 如果没有定义 \"systemProperties\" 这个 bean，那么 Spring 会 \"手动\" 注册一个 if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) { beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties()); } // 如果没有定义 \"systemEnvironment\" 这个 bean，那么 Spring 会 \"手动\" 注册一个 if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) { beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment()); }} 在上面这块代码中，Spring 对一些特殊的 bean 进行了处理，读者如果暂时还不能消化它们也没有关系，慢慢往下看。 初始化所有的 singleton beans我们的重点当然是 finishBeanFactoryInitialization(beanFactory); 这个巨头了，这里会负责初始化所有的 singleton beans。 注意，后面的描述中，我都会使用初始化或预初始化来代表这个阶段，Spring 会在这个阶段完成所有的 singleton beans 的实例化。 我们来总结一下，到目前为止，应该说 BeanFactory 已经创建完成，并且所有的实现了 BeanFactoryPostProcessor 接口的 Bean 都已经初始化并且其中的 postProcessBeanFactory(factory) 方法已经得到回调执行了。而且 Spring 已经“手动”注册了一些特殊的 Bean，如 environment、systemProperties 等。 剩下的就是初始化 singleton beans 了，我们知道它们是单例的，如果没有设置懒加载，那么 Spring 会在接下来初始化所有的 singleton beans。 // AbstractApplicationContext.java 834 1234567891011121314151617181920212223242526272829303132333435363738394041// 初始化剩余的 singleton beansprotected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) { // 首先，初始化名字为 conversionService 的 Bean。本着送佛送到西的精神，我在附录中简单介绍了一下 ConversionService，因为这实在太实用了 // 什么，看代码这里没有初始化 Bean 啊！ // 注意了，初始化的动作包装在 beanFactory.getBean(...) 中，这里先不说细节，先往下看吧 if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp; beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) { beanFactory.setConversionService( beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)); } // Register a default embedded value resolver if no bean post-processor // (such as a PropertyPlaceholderConfigurer bean) registered any before: // at this point, primarily for resolution in annotation attribute values. if (!beanFactory.hasEmbeddedValueResolver()) { beanFactory.addEmbeddedValueResolver(new StringValueResolver() { @Override public String resolveStringValue(String strVal) { return getEnvironment().resolvePlaceholders(strVal); } }); } // 先初始化 LoadTimeWeaverAware 类型的 Bean // 之前也说过，这是 AspectJ 相关的内容，放心跳过吧 String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false); for (String weaverAwareName : weaverAwareNames) { getBean(weaverAwareName); } // Stop using the temporary ClassLoader for type matching. beanFactory.setTempClassLoader(null); // 没什么别的目的，因为到这一步的时候，Spring 已经开始预初始化 singleton beans 了， // 肯定不希望这个时候还出现 bean 定义解析、加载、注册。 beanFactory.freezeConfiguration(); // 开始初始化 beanFactory.preInstantiateSingletons();} 从上面最后一行往里看，我们就又回到 DefaultListableBeanFactory 这个类了，这个类大家应该都不陌生了吧。 preInstantiateSingletons// DefaultListableBeanFactory 728 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768@Overridepublic void preInstantiateSingletons() throws BeansException { if (this.logger.isDebugEnabled()) { this.logger.debug(\"Pre-instantiating singletons in \" + this); } // this.beanDefinitionNames 保存了所有的 beanNames List&lt;String&gt; beanNames = new ArrayList&lt;String&gt;(this.beanDefinitionNames); // 下面这个循环，触发所有的非懒加载的 singleton beans 的初始化操作 for (String beanName : beanNames) { // 合并父 Bean 中的配置，注意 &lt;bean id=\"\" class=\"\" parent=\"\" /&gt; 中的 parent，用的不多吧， // 考虑到这可能会影响大家的理解，我在附录中解释了一下 \"Bean 继承\"，不了解的请到附录中看一下 RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName); // 非抽象、非懒加载的 singletons。如果配置了 'abstract = true'，那是不需要初始化的 if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) { // 处理 FactoryBean(读者如果不熟悉 FactoryBean，请移步附录区了解) if (isFactoryBean(beanName)) { // FactoryBean 的话，在 beanName 前面加上 ‘&amp;’ 符号。再调用 getBean，getBean 方法别急 final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName); // 判断当前 FactoryBean 是否是 SmartFactoryBean 的实现，此处忽略，直接跳过 boolean isEagerInit; if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) { isEagerInit = AccessController.doPrivileged(new PrivilegedAction&lt;Boolean&gt;() { @Override public Boolean run() { return ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit(); } }, getAccessControlContext()); } else { isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp; ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit()); } if (isEagerInit) { getBean(beanName); } } else { // 对于普通的 Bean，只要调用 getBean(beanName) 这个方法就可以进行初始化了 getBean(beanName); } } } // 到这里说明所有的非懒加载的 singleton beans 已经完成了初始化 // 如果我们定义的 bean 是实现了 SmartInitializingSingleton 接口的，那么在这里得到回调，忽略 for (String beanName : beanNames) { Object singletonInstance = getSingleton(beanName); if (singletonInstance instanceof SmartInitializingSingleton) { final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance; if (System.getSecurityManager() != null) { AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() { @Override public Object run() { smartSingleton.afterSingletonsInstantiated(); return null; } }, getAccessControlContext()); } else { smartSingleton.afterSingletonsInstantiated(); } } }} 接下来，我们就进入到 getBean(beanName) 方法了，这个方法我们经常用来从 BeanFactory 中获取一个 Bean，而初始化的过程也封装到了这个方法里。 getBean在继续前进之前，读者应该具备 FactoryBean 的知识，如果读者还不熟悉，请移步附录部分了解 FactoryBean。 // AbstractBeanFactory 196 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176@Overridepublic Object getBean(String name) throws BeansException { return doGetBean(name, null, null, false);}// 我们在剖析初始化 Bean 的过程，但是 getBean 方法我们经常是用来从容器中获取 Bean 用的，注意切换思路，// 已经初始化过了就从容器中直接返回，否则就先初始化再返回@SuppressWarnings(\"unchecked\")protected &lt;T&gt; T doGetBean( final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly) throws BeansException { // 获取一个 “正统的” beanName，处理两种情况，一个是前面说的 FactoryBean(前面带 ‘&amp;’)， // 一个是别名问题，因为这个方法是 getBean，获取 Bean 用的，你要是传一个别名进来，是完全可以的 final String beanName = transformedBeanName(name); // 注意跟着这个，这个是返回值 Object bean; // 检查下是不是已经创建过了 Object sharedInstance = getSingleton(beanName); // 这里说下 args 呗，虽然看上去一点不重要。前面我们一路进来的时候都是 getBean(beanName)， // 所以 args 传参其实是 null 的，但是如果 args 不为空的时候，那么意味着调用方不是希望获取 Bean，而是创建 Bean if (sharedInstance != null &amp;&amp; args == null) { if (logger.isDebugEnabled()) { if (isSingletonCurrentlyInCreation(beanName)) { logger.debug(\"...\"); } else { logger.debug(\"Returning cached instance of singleton bean '\" + beanName + \"'\"); } } // 下面这个方法：如果是普通 Bean 的话，直接返回 sharedInstance， // 如果是 FactoryBean 的话，返回它创建的那个实例对象 // (FactoryBean 知识，读者若不清楚请移步附录) bean = getObjectForBeanInstance(sharedInstance, name, beanName, null); } else { if (isPrototypeCurrentlyInCreation(beanName)) { // 创建过了此 beanName 的 prototype 类型的 bean，那么抛异常， // 往往是因为陷入了循环引用 throw new BeanCurrentlyInCreationException(beanName); } // 检查一下这个 BeanDefinition 在容器中是否存在 BeanFactory parentBeanFactory = getParentBeanFactory(); if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) { // 如果当前容器不存在这个 BeanDefinition，试试父容器中有没有 String nameToLookup = originalBeanName(name); if (args != null) { // 返回父容器的查询结果 return (T) parentBeanFactory.getBean(nameToLookup, args); } else { // No args -&gt; delegate to standard getBean method. return parentBeanFactory.getBean(nameToLookup, requiredType); } } if (!typeCheckOnly) { // typeCheckOnly 为 false，将当前 beanName 放入一个 alreadyCreated 的 Set 集合中。 markBeanAsCreated(beanName); } /* * 稍稍总结一下： * 到这里的话，要准备创建 Bean 了，对于 singleton 的 Bean 来说，容器中还没创建过此 Bean； * 对于 prototype 的 Bean 来说，本来就是要创建一个新的 Bean。 */ try { final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName); checkMergedBeanDefinition(mbd, beanName, args); // 先初始化依赖的所有 Bean，这个很好理解。 // 注意，这里的依赖指的是 depends-on 中定义的依赖 String[] dependsOn = mbd.getDependsOn(); if (dependsOn != null) { for (String dep : dependsOn) { // 检查是不是有循环依赖，这里的循环依赖和我们前面说的循环依赖又不一样，这里肯定是不允许出现的，不然要乱套了，读者想一下就知道了 if (isDependent(beanName, dep)) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Circular depends-on relationship between '\" + beanName + \"' and '\" + dep + \"'\"); } // 注册一下依赖关系 registerDependentBean(dep, beanName); // 先初始化被依赖项 getBean(dep); } } // 如果是 singleton scope 的，创建 singleton 的实例 if (mbd.isSingleton()) { sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() { @Override public Object getObject() throws BeansException { try { // 执行创建 Bean，详情后面再说 return createBean(beanName, mbd, args); } catch (BeansException ex) { destroySingleton(beanName); throw ex; } } }); bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); } // 如果是 prototype scope 的，创建 prototype 的实例 else if (mbd.isPrototype()) { // It's a prototype -&gt; create a new instance. Object prototypeInstance = null; try { beforePrototypeCreation(beanName); // 执行创建 Bean prototypeInstance = createBean(beanName, mbd, args); } finally { afterPrototypeCreation(beanName); } bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); } // 如果不是 singleton 和 prototype 的话，需要委托给相应的实现类来处理 else { String scopeName = mbd.getScope(); final Scope scope = this.scopes.get(scopeName); if (scope == null) { throw new IllegalStateException(\"No Scope registered for scope name '\" + scopeName + \"'\"); } try { Object scopedInstance = scope.get(beanName, new ObjectFactory&lt;Object&gt;() { @Override public Object getObject() throws BeansException { beforePrototypeCreation(beanName); try { // 执行创建 Bean return createBean(beanName, mbd, args); } finally { afterPrototypeCreation(beanName); } } }); bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd); } catch (IllegalStateException ex) { throw new BeanCreationException(beanName, \"Scope '\" + scopeName + \"' is not active for the current thread; consider \" + \"defining a scoped proxy for this bean if you intend to refer to it from a singleton\", ex); } } } catch (BeansException ex) { cleanupAfterBeanCreationFailure(beanName); throw ex; } } // 最后，检查一下类型对不对，不对的话就抛异常，对的话就返回了 if (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isInstance(bean)) { try { return getTypeConverter().convertIfNecessary(bean, requiredType); } catch (TypeMismatchException ex) { if (logger.isDebugEnabled()) { logger.debug(\"Failed to convert bean '\" + name + \"' to required type '\" + ClassUtils.getQualifiedName(requiredType) + \"'\", ex); } throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass()); } } return (T) bean;} 大家应该也猜到了，接下来当然是分析 createBean 方法： 1protected abstract Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException; 第三个参数 args 数组代表创建实例需要的参数，不就是给构造方法用的参数，或者是工厂 Bean 的参数嘛，不过要注意，在我们的初始化阶段，args 是 null。 这回我们要到一个新的类了 AbstractAutowireCapableBeanFactory，看类名，AutowireCapable？类名是不是也说明了点问题了。 主要是为了以下场景，采用 @Autowired 注解注入属性值： 12345678public class MessageServiceImpl implements MessageService { @Autowired private UserService userService; public String getMessage() { return userService.getMessage(); }} 1&lt;bean id=\"messageService\" class=\"com.javadoop.example.MessageServiceImpl\" /&gt; 以上这种属于混用了 xml 和 注解 两种方式的配置方式，Spring 会处理这种情况。 好了，读者要知道这么回事就可以了，继续向前。 // AbstractAutowireCapableBeanFactory 447 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Central method of this class: creates a bean instance, * populates the bean instance, applies post-processors, etc. * @see #doCreateBean */@Overrideprotected Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException { if (logger.isDebugEnabled()) { logger.debug(\"Creating instance of bean '\" + beanName + \"'\"); } RootBeanDefinition mbdToUse = mbd; // 确保 BeanDefinition 中的 Class 被加载 Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName); if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) { mbdToUse = new RootBeanDefinition(mbd); mbdToUse.setBeanClass(resolvedClass); } // 准备方法覆写，这里又涉及到一个概念：MethodOverrides，它来自于 bean 定义中的 &lt;lookup-method /&gt; // 和 &lt;replaced-method /&gt;，如果读者感兴趣，回到 bean 解析的地方看看对这两个标签的解析。 // 我在附录中也对这两个标签的相关知识点进行了介绍，读者可以移步去看看 try { mbdToUse.prepareMethodOverrides(); } catch (BeanDefinitionValidationException ex) { throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, \"Validation of method overrides failed\", ex); } try { // 让 InstantiationAwareBeanPostProcessor 在这一步有机会返回代理， // 在 《Spring AOP 源码分析》那篇文章中有解释，这里先跳过 Object bean = resolveBeforeInstantiation(beanName, mbdToUse); if (bean != null) { return bean; } } catch (Throwable ex) { throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, \"BeanPostProcessor before instantiation of bean failed\", ex); } // 重头戏，创建 bean Object beanInstance = doCreateBean(beanName, mbdToUse, args); if (logger.isDebugEnabled()) { logger.debug(\"Finished creating instance of bean '\" + beanName + \"'\"); } return beanInstance;} 创建 Bean我们继续往里看 doCreateBean 这个方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125/** * Actually create the specified bean. Pre-creation processing has already happened * at this point, e.g. checking {@code postProcessBeforeInstantiation} callbacks. * &lt;p&gt;Differentiates between default bean instantiation, use of a * factory method, and autowiring a constructor. * @param beanName the name of the bean * @param mbd the merged bean definition for the bean * @param args explicit arguments to use for constructor or factory method invocation * @return a new instance of the bean * @throws BeanCreationException if the bean could not be created * @see #instantiateBean * @see #instantiateUsingFactoryMethod * @see #autowireConstructor */protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) throws BeanCreationException { // Instantiate the bean. BeanWrapper instanceWrapper = null; if (mbd.isSingleton()) { instanceWrapper = this.factoryBeanInstanceCache.remove(beanName); } if (instanceWrapper == null) { // 说明不是 FactoryBean，这里实例化 Bean，这里非常关键，细节之后再说 instanceWrapper = createBeanInstance(beanName, mbd, args); } // 这个就是 Bean 里面的 我们定义的类 的实例，很多地方我直接描述成 \"bean 实例\" final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null); // 类型 Class&lt;?&gt; beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null); mbd.resolvedTargetType = beanType; // 建议跳过吧，涉及接口：MergedBeanDefinitionPostProcessor synchronized (mbd.postProcessingLock) { if (!mbd.postProcessed) { try { // MergedBeanDefinitionPostProcessor，这个我真不展开说了，直接跳过吧，很少用的 applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); } catch (Throwable ex) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Post-processing of merged bean definition failed\", ex); } mbd.postProcessed = true; } } // Eagerly cache singletons to be able to resolve circular references // even when triggered by lifecycle interfaces like BeanFactoryAware. // 下面这块代码是为了解决循环依赖的问题，以后有时间，我再对循环依赖这个问题进行解析吧 boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName)); if (earlySingletonExposure) { if (logger.isDebugEnabled()) { logger.debug(\"Eagerly caching bean '\" + beanName + \"' to allow for resolving potential circular references\"); } addSingletonFactory(beanName, new ObjectFactory&lt;Object&gt;() { @Override public Object getObject() throws BeansException { return getEarlyBeanReference(beanName, mbd, bean); } }); } // Initialize the bean instance. Object exposedObject = bean; try { // 这一步也是非常关键的，这一步负责属性装配，因为前面的实例只是实例化了，并没有设值，这里就是设值 populateBean(beanName, mbd, instanceWrapper); if (exposedObject != null) { // 还记得 init-method 吗？还有 InitializingBean 接口？还有 BeanPostProcessor 接口？ // 这里就是处理 bean 初始化完成后的各种回调 exposedObject = initializeBean(beanName, exposedObject, mbd); } } catch (Throwable ex) { if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) { throw (BeanCreationException) ex; } else { throw new BeanCreationException( mbd.getResourceDescription(), beanName, \"Initialization of bean failed\", ex); } } if (earlySingletonExposure) { // Object earlySingletonReference = getSingleton(beanName, false); if (earlySingletonReference != null) { if (exposedObject == bean) { exposedObject = earlySingletonReference; } else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) { String[] dependentBeans = getDependentBeans(beanName); Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;String&gt;(dependentBeans.length); for (String dependentBean : dependentBeans) { if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) { actualDependentBeans.add(dependentBean); } } if (!actualDependentBeans.isEmpty()) { throw new BeanCurrentlyInCreationException(beanName, \"Bean with name '\" + beanName + \"' has been injected into other beans [\" + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) + \"] in its raw version as part of a circular reference, but has eventually been \" + \"wrapped. This means that said other beans do not use the final version of the \" + \"bean. This is often the result of over-eager type matching - consider using \" + \"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.\"); } } } } // Register bean as disposable. try { registerDisposableBeanIfNecessary(beanName, bean, mbd); } catch (BeanDefinitionValidationException ex) { throw new BeanCreationException( mbd.getResourceDescription(), beanName, \"Invalid destruction signature\", ex); } return exposedObject;} 到这里，我们已经分析完了 doCreateBean 方法，总的来说，我们已经说完了整个初始化流程。 接下来我们挑 doCreateBean 中的三个细节出来说说。一个是创建 Bean 实例的 createBeanInstance 方法，一个是依赖注入的 populateBean 方法，还有就是回调方法 initializeBean。 注意了，接下来的这三个方法要认真说那也是极其复杂的，很多地方我就点到为止了，感兴趣的读者可以自己往里看，最好就是碰到不懂的，自己写代码去调试它。 创建 Bean 实例我们先看看 createBeanInstance 方法。需要说明的是，这个方法如果每个分支都分析下去，必然也是极其复杂冗长的，我们挑重点说。此方法的目的就是实例化我们指定的类。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args) { // 确保已经加载了此 class Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName); // 校验一下这个类的访问权限 if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean class isn't public, and non-public access not allowed: \" + beanClass.getName()); } if (mbd.getFactoryMethodName() != null) { // 采用工厂方法实例化，不熟悉这个概念的读者请看附录，注意，不是 FactoryBean return instantiateUsingFactoryMethod(beanName, mbd, args); } // 如果不是第一次创建，比如第二次创建 prototype bean。 // 这种情况下，我们可以从第一次创建知道，采用无参构造函数，还是构造函数依赖注入 来完成实例化 boolean resolved = false; boolean autowireNecessary = false; if (args == null) { synchronized (mbd.constructorArgumentLock) { if (mbd.resolvedConstructorOrFactoryMethod != null) { resolved = true; autowireNecessary = mbd.constructorArgumentsResolved; } } } if (resolved) { if (autowireNecessary) { // 构造函数依赖注入 return autowireConstructor(beanName, mbd, null, null); } else { // 无参构造函数 return instantiateBean(beanName, mbd); } } // 判断是否采用有参构造函数 Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName); if (ctors != null || mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR || mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) { // 构造函数依赖注入 return autowireConstructor(beanName, mbd, ctors, args); } // 调用无参构造函数 return instantiateBean(beanName, mbd);} 挑个简单的无参构造函数构造实例来看看： 123456789101112131415161718192021222324252627protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) { try { Object beanInstance; final BeanFactory parent = this; if (System.getSecurityManager() != null) { beanInstance = AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() { @Override public Object run() { return getInstantiationStrategy().instantiate(mbd, beanName, parent); } }, getAccessControlContext()); } else { // 实例化 beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent); } // 包装一下，返回 BeanWrapper bw = new BeanWrapperImpl(beanInstance); initBeanWrapper(bw); return bw; } catch (Throwable ex) { throw new BeanCreationException( mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex); }} 我们可以看到，关键的地方在于： 1beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent); 这里会进行实际的实例化过程，我们进去看看: // SimpleInstantiationStrategy 59 123456789101112131415161718192021222324252627282930313233343536373839404142@Overridepublic Object instantiate(RootBeanDefinition bd, String beanName, BeanFactory owner) { // 如果不存在方法覆写，那就使用 java 反射进行实例化，否则使用 CGLIB, // 方法覆写 请参见附录\"方法注入\"中对 lookup-method 和 replaced-method 的介绍 if (bd.getMethodOverrides().isEmpty()) { Constructor&lt;?&gt; constructorToUse; synchronized (bd.constructorArgumentLock) { constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod; if (constructorToUse == null) { final Class&lt;?&gt; clazz = bd.getBeanClass(); if (clazz.isInterface()) { throw new BeanInstantiationException(clazz, \"Specified class is an interface\"); } try { if (System.getSecurityManager() != null) { constructorToUse = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;() { @Override public Constructor&lt;?&gt; run() throws Exception { return clazz.getDeclaredConstructor((Class[]) null); } }); } else { constructorToUse = clazz.getDeclaredConstructor((Class[]) null); } bd.resolvedConstructorOrFactoryMethod = constructorToUse; } catch (Throwable ex) { throw new BeanInstantiationException(clazz, \"No default constructor found\", ex); } } } // 利用构造方法进行实例化 return BeanUtils.instantiateClass(constructorToUse); } else { // 存在方法覆写，利用 CGLIB 来完成实例化，需要依赖于 CGLIB 生成子类，这里就不展开了。 // tips: 因为如果不使用 CGLIB 的话，存在 override 的情况 JDK 并没有提供相应的实例化支持 return instantiateWithMethodInjection(bd, beanName, owner); }} 到这里，我们就算实例化完成了。我们开始说怎么进行属性注入。 bean 属性注入看完了 createBeanInstance(…) 方法，我们来看看 populateBean(…) 方法，该方法负责进行属性设值，处理依赖。 // AbstractAutowireCapableBeanFactory 1203 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778protected void populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw) { // bean 实例的所有属性都在这里了 PropertyValues pvs = mbd.getPropertyValues(); if (bw == null) { if (!pvs.isEmpty()) { throw new BeanCreationException( mbd.getResourceDescription(), beanName, \"Cannot apply property values to null instance\"); } else { // Skip property population phase for null instance. return; } } // 到这步的时候，bean 实例化完成（通过工厂方法或构造方法），但是还没开始属性设值， // InstantiationAwareBeanPostProcessor 的实现类可以在这里对 bean 进行状态修改， // 我也没找到有实际的使用，所以我们暂且忽略这块吧 boolean continueWithPropertyPopulation = true; if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) { for (BeanPostProcessor bp : getBeanPostProcessors()) { if (bp instanceof InstantiationAwareBeanPostProcessor) { InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; // 如果返回 false，代表不需要进行后续的属性设值，也不需要再经过其他的 BeanPostProcessor 的处理 if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) { continueWithPropertyPopulation = false; break; } } } } if (!continueWithPropertyPopulation) { return; } if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME || mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) { MutablePropertyValues newPvs = new MutablePropertyValues(pvs); // 通过名字找到所有属性值，如果是 bean 依赖，先初始化依赖的 bean。记录依赖关系 if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) { autowireByName(beanName, mbd, bw, newPvs); } // 通过类型装配。复杂一些 if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) { autowireByType(beanName, mbd, bw, newPvs); } pvs = newPvs; } boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors(); boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE); if (hasInstAwareBpps || needsDepCheck) { PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching); if (hasInstAwareBpps) { for (BeanPostProcessor bp : getBeanPostProcessors()) { if (bp instanceof InstantiationAwareBeanPostProcessor) { InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; // 这里有个非常有用的 BeanPostProcessor 进到这里: AutowiredAnnotationBeanPostProcessor // 对采用 @Autowired、@Value 注解的依赖进行设值，这里的内容也是非常丰富的，不过本文不会展开说了，感兴趣的读者请自行研究 pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName); if (pvs == null) { return; } } } } if (needsDepCheck) { checkDependencies(beanName, mbd, filteredPds, pvs); } } // 设置 bean 实例的属性值 applyPropertyValues(beanName, mbd, bw, pvs);} initializeBean属性注入完成后，这一步其实就是处理各种回调了，这块代码比较简单。 1234567891011121314151617181920212223242526272829303132333435363738protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) { if (System.getSecurityManager() != null) { AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() { @Override public Object run() { invokeAwareMethods(beanName, bean); return null; } }, getAccessControlContext()); } else { // 如果 bean 实现了 BeanNameAware、BeanClassLoaderAware 或 BeanFactoryAware 接口，回调 invokeAwareMethods(beanName, bean); } Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) { // BeanPostProcessor 的 postProcessBeforeInitialization 回调 wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); } try { // 处理 bean 中定义的 init-method， // 或者如果 bean 实现了 InitializingBean 接口，调用 afterPropertiesSet() 方法 invokeInitMethods(beanName, wrappedBean, mbd); } catch (Throwable ex) { throw new BeanCreationException( (mbd != null ? mbd.getResourceDescription() : null), beanName, \"Invocation of init method failed\", ex); } if (mbd == null || !mbd.isSynthetic()) { // BeanPostProcessor 的 postProcessAfterInitialization 回调 wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); } return wrappedBean;} 大家发现没有，BeanPostProcessor 的两个回调都发生在这边，只不过中间处理了 init-method，是不是和读者原来的认知有点不一样了？ 附录id 和 name每个 Bean 在 Spring 容器中都有一个唯一的名字（beanName）和 0 个或多个别名（aliases）。 我们从 Spring 容器中获取 Bean 的时候，可以根据 beanName，也可以通过别名。 1beanFactory.getBean(\"beanName or alias\"); 在配置 &lt;bean /&gt; 的过程中，我们可以配置 id 和 name，看几个例子就知道是怎么回事了。 1&lt;bean id=\"messageService\" name=\"m1, m2, m3\" class=\"com.javadoop.example.MessageServiceImpl\"&gt; 以上配置的结果就是：beanName 为 messageService，别名有 3 个，分别为 m1、m2、m3。 1&lt;bean name=\"m1, m2, m3\" class=\"com.javadoop.example.MessageServiceImpl\" /&gt; 以上配置的结果就是：beanName 为 m1，别名有 2 个，分别为 m2、m3。 1&lt;bean class=\"com.javadoop.example.MessageServiceImpl\"&gt; beanName 为：com.javadoop.example.MessageServiceImpl#0， 别名 1 个，为： com.javadoop.example.MessageServiceImpl 1&lt;bean id=\"messageService\" class=\"com.javadoop.example.MessageServiceImpl\"&gt; 以上配置的结果就是：beanName 为 messageService，没有别名。 配置是否允许 Bean 覆盖、是否允许循环依赖我们说过，默认情况下，allowBeanDefinitionOverriding 属性为 null。如果在同一配置文件中 Bean id 或 name 重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。 可是有些时候我们希望在系统启动的过程中就严格杜绝发生 Bean 覆盖，因为万一出现这种情况，会增加我们排查问题的成本。 循环依赖说的是 A 依赖 B，而 B 又依赖 A。或者是 A 依赖 B，B 依赖 C，而 C 却依赖 A。默认 allowCircularReferences 也是 null。 它们两个属性是一起出现的，必然可以在同一个地方一起进行配置。 添加这两个属性的作者 Juergen Hoeller 在这个 jira 的讨论中说明了怎么配置这两个属性。 123456789public class NoBeanOverridingContextLoader extends ContextLoader { @Override protected void customizeContext(ServletContext servletContext, ConfigurableWebApplicationContext applicationContext) { super.customizeContext(servletContext, applicationContext); AbstractRefreshableApplicationContext arac = (AbstractRefreshableApplicationContext) applicationContext; arac.setAllowBeanDefinitionOverriding(false); }} 12345678public class MyContextLoaderListener extends org.springframework.web.context.ContextLoaderListener { @Override protected ContextLoader createContextLoader() { return new NoBeanOverridingContextLoader(); } } 123&lt;listener&gt; &lt;listener-class&gt;com.javadoop.MyContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; 如果以上方式不能满足你的需求，请参考这个链接：解决spring中不同配置文件中存在name或者id相同的bean可能引起的问题 profile我们可以把不同环境的配置分别配置到单独的文件中，举个例子： 1234567891011&lt;beans profile=\"development\" xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\" xsi:schemaLocation=\"...\"&gt; &lt;jdbc:embedded-database id=\"dataSource\"&gt; &lt;jdbc:script location=\"classpath:com/bank/config/sql/schema.sql\"/&gt; &lt;jdbc:script location=\"classpath:com/bank/config/sql/test-data.sql\"/&gt; &lt;/jdbc:embedded-database&gt;&lt;/beans&gt; 12345678&lt;beans profile=\"production\" xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:jee=\"http://www.springframework.org/schema/jee\" xsi:schemaLocation=\"...\"&gt; &lt;jee:jndi-lookup id=\"dataSource\" jndi-name=\"java:comp/env/jdbc/datasource\"/&gt;&lt;/beans&gt; 应该不必做过多解释了吧，看每个文件第一行的 profile=””。 当然，我们也可以在一个配置文件中使用： 1234567891011121314151617&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\" xmlns:jee=\"http://www.springframework.org/schema/jee\" xsi:schemaLocation=\"...\"&gt; &lt;beans profile=\"development\"&gt; &lt;jdbc:embedded-database id=\"dataSource\"&gt; &lt;jdbc:script location=\"classpath:com/bank/config/sql/schema.sql\"/&gt; &lt;jdbc:script location=\"classpath:com/bank/config/sql/test-data.sql\"/&gt; &lt;/jdbc:embedded-database&gt; &lt;/beans&gt; &lt;beans profile=\"production\"&gt; &lt;jee:jndi-lookup id=\"dataSource\" jndi-name=\"java:comp/env/jdbc/datasource\"/&gt; &lt;/beans&gt;&lt;/beans&gt; 理解起来也很简单吧。 接下来的问题是，怎么使用特定的 profile 呢？Spring 在启动的过程中，会去寻找 “spring.profiles.active” 的属性值，根据这个属性值来的。那怎么配置这个值呢？ Spring 会在这几个地方寻找 spring.profiles.active 的属性值：操作系统环境变量、JVM 系统变量、web.xml 中定义的参数、JNDI。 最简单的方式莫过于在程序启动的时候指定： 1-Dspring.profiles.active=\"profile1,profile2\" profile 可以激活多个 当然，我们也可以通过代码的形式从 Environment 中设置 profile： 1234AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();ctx.getEnvironment().setActiveProfiles(\"development\");ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);ctx.refresh(); // 重启 如果是 Spring Boot 的话更简单，我们一般会创建 application.properties、application-dev.properties、application-prod.properties 等文件，其中 application.properties 配置各个环境通用的配置，application-{profile}.properties 中配置特定环境的配置，然后在启动的时候指定 profile： 1java -Dspring.profiles.active=prod -jar JavaDoop.jar 如果是单元测试中使用的话，在测试类中使用 @ActiveProfiles 指定，这里就不展开了。 工厂模式生成 Bean请读者注意 factory-bean 和 FactoryBean 的区别。这节说的是前者，是说静态工厂或实例工厂，而后者是 Spring 中的特殊接口，代表一类特殊的 Bean，附录的下面一节会介绍 FactoryBean。 设计模式里，工厂方法模式分静态工厂和实例工厂，我们分别看看 Spring 中怎么配置这两个，来个代码示例就什么都清楚了。 静态工厂： 123&lt;bean id=\"clientService\" class=\"examples.ClientService\" factory-method=\"createInstance\"/&gt; 123456789public class ClientService { private static ClientService clientService = new ClientService(); private ClientService() {} // 静态方法 public static ClientService createInstance() { return clientService; }} 实例工厂： 1234567891011&lt;bean id=\"serviceLocator\" class=\"examples.DefaultServiceLocator\"&gt; &lt;!-- inject any dependencies required by this locator bean --&gt;&lt;/bean&gt;&lt;bean id=\"clientService\" factory-bean=\"serviceLocator\" factory-method=\"createClientServiceInstance\"/&gt;&lt;bean id=\"accountService\" factory-bean=\"serviceLocator\" factory-method=\"createAccountServiceInstance\"/&gt; 1234567891011121314public class DefaultServiceLocator { private static ClientService clientService = new ClientServiceImpl(); private static AccountService accountService = new AccountServiceImpl(); public ClientService createClientServiceInstance() { return clientService; } public AccountService createAccountServiceInstance() { return accountService; }} FactoryBeanFactoryBean 适用于 Bean 的创建过程比较复杂的场景，比如数据库连接池的创建。 12345public interface FactoryBean&lt;T&gt; { T getObject() throws Exception; Class&lt;T&gt; getObjectType(); boolean isSingleton();} 1234public class Person { private Car car ; private void setCar(Car car){ this.car = car; } } 我们假设现在需要创建一个 Person 的 Bean，首先我们需要一个 Car 的实例，我们这里假设 Car 的实例创建很麻烦，那么我们可以把创建 Car 的复杂过程包装起来： 123456789101112131415161718192021public class MyCarFactoryBean implements FactoryBean&lt;Car&gt;{ private String make; private int year ; public void setMake(String m){ this.make =m ; } public void setYear(int y){ this.year = y; } public Car getObject(){ // 这里我们假设 Car 的实例化过程非常复杂，反正就不是几行代码可以写完的那种 CarBuilder cb = CarBuilder.car(); if(year!=0) cb.setYear(this.year); if(StringUtils.hasText(this.make)) cb.setMake( this.make ); return cb.factory(); } public Class&lt;Car&gt; getObjectType() { return Car.class ; } public boolean isSingleton() { return false; }} 我们看看装配的时候是怎么配置的： 1234567&lt;bean class = \"com.javadoop.MyCarFactoryBean\" id = \"car\"&gt; &lt;property name = \"make\" value =\"Honda\"/&gt; &lt;property name = \"year\" value =\"1984\"/&gt;&lt;/bean&gt;&lt;bean class = \"com.javadoop.Person\" id = \"josh\"&gt; &lt;property name = \"car\" ref = \"car\"/&gt;&lt;/bean&gt; 看到不一样了吗？id 为 “car” 的 bean 其实指定的是一个 FactoryBean，不过配置的时候，我们直接让配置 Person 的 Bean 直接依赖于这个 FactoryBean 就可以了。中间的过程 Spring 已经封装好了。 说到这里，我们再来点干货。我们知道，现在还用 xml 配置 Bean 依赖的越来越少了，更多时候，我们可能会采用 java config 的方式来配置，这里有什么不一样呢？ 12345678910111213141516171819@Configuration public class CarConfiguration { @Bean public MyCarFactoryBean carFactoryBean(){ MyCarFactoryBean cfb = new MyCarFactoryBean(); cfb.setMake(\"Honda\"); cfb.setYear(1984); return cfb; } @Bean public Person aPerson(){ Person person = new Person(); // 注意这里的不同 person.setCar(carFactoryBean().getObject()); return person; } } 这个时候，其实我们的思路也很简单，把 MyCarFactoryBean 看成是一个简单的 Bean 就可以了，不必理会什么 FactoryBean，它是不是 FactoryBean 和我们没关系。 初始化 Bean 的回调有以下四种方案： 1&lt;bean id=\"exampleInitBean\" class=\"examples.ExampleBean\" init-method=\"init\"/&gt; 123456public class AnotherExampleBean implements InitializingBean { public void afterPropertiesSet() { // do some initialization work }} 1234@Bean(initMethod = \"init\")public Foo foo() { return new Foo();} 1234@PostConstructpublic void init() { } 销毁 Bean 的回调1&lt;bean id=\"exampleInitBean\" class=\"examples.ExampleBean\" destroy-method=\"cleanup\"/&gt; 123456public class AnotherExampleBean implements DisposableBean { public void destroy() { // do some destruction work (like releasing pooled connections) }} 1234@Bean(destroyMethod = \"cleanup\")public Bar bar() { return new Bar();} 1234@PreDestroypublic void cleanup() { } ConversionService既然文中说到了这个，顺便提一下好了。 最有用的场景就是，它用来将前端传过来的参数和后端的 controller 方法上的参数进行绑定的时候用。 像前端传过来的字符串、整数要转换为后端的 String、Integer 很容易，但是如果 controller 方法需要的是一个枚举值，或者是 Date 这些非基础类型（含基础类型包装类）值的时候，我们就可以考虑采用 ConversionService 来进行转换。 12345678&lt;bean id=\"conversionService\" class=\"org.springframework.context.support.ConversionServiceFactoryBean\"&gt; &lt;property name=\"converters\"&gt; &lt;list&gt; &lt;bean class=\"com.javadoop.learning.utils.StringToEnumConverterFactory\"/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; ConversionService 接口很简单，所以要自定义一个 convert 的话也很简单。 下面再说一个实现这种转换很简单的方式，那就是实现 Converter 接口。 来看一个很简单的例子，这样比什么都管用。 1234567891011public class StringToDateConverter implements Converter&lt;String, Date&gt; { @Override public Date convert(String source) { try { return DateUtils.parseDate(source, \"yyyy-MM-dd\", \"yyyy-MM-dd HH:mm:ss\", \"yyyy-MM-dd HH:mm\", \"HH:mm:ss\", \"HH:mm\"); } catch (ParseException e) { return null; } }} 只要注册这个 Bean 就可以了。这样，前端往后端传的时间描述字符串就很容易绑定成 Date 类型了，不需要其他任何操作。 Bean 继承在初始化 Bean 的地方，我们说过了这个： 1RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName); 这里涉及到的就是 &lt;bean parent=&quot;&quot; /&gt; 中的 parent 属性，我们来看看 Spring 中是用这个来干什么的。 首先，我们要明白，这里的继承和 java 语法中的继承没有任何关系，不过思路是相通的。child bean 会继承 parent bean 的所有配置，也可以覆盖一些配置，当然也可以新增额外的配置。 Spring 中提供了继承自 AbstractBeanDefinition 的 ChildBeanDefinition 来表示 child bean。 看如下一个例子: 12345678910&lt;bean id=\"inheritedTestBean\" abstract=\"true\" class=\"org.springframework.beans.TestBean\"&gt; &lt;property name=\"name\" value=\"parent\"/&gt; &lt;property name=\"age\" value=\"1\"/&gt;&lt;/bean&gt;&lt;bean id=\"inheritsWithDifferentClass\" class=\"org.springframework.beans.DerivedTestBean\" parent=\"inheritedTestBean\" init-method=\"initialize\"&gt; &lt;property name=\"name\" value=\"override\"/&gt;&lt;/bean&gt; parent bean 设置了 abstract=&quot;true&quot; 所以它不会被实例化，child bean 继承了 parent bean 的两个属性，但是对 name 属性进行了覆写。 child bean 会继承 scope、构造器参数值、属性值、init-method、destroy-method 等等。 当然，我不是说 parent bean 中的 abstract = true 在这里是必须的，只是说如果加上了以后 Spring 在实例化 singleton beans 的时候会忽略这个 bean。 比如下面这个极端 parent bean，它没有指定 class，所以毫无疑问，这个 bean 的作用就是用来充当模板用的 parent bean，此处就必须加上 abstract = true。 1234&lt;bean id=\"inheritedTestBeanWithoutClass\" abstract=\"true\"&gt; &lt;property name=\"name\" value=\"parent\"/&gt; &lt;property name=\"age\" value=\"1\"/&gt;&lt;/bean&gt; 方法注入一般来说，我们的应用中大多数的 Bean 都是 singleton 的。singleton 依赖 singleton，或者 prototype 依赖 prototype 都很好解决，直接设置属性依赖就可以了。 但是，如果是 singleton 依赖 prototype 呢？这个时候不能用属性依赖，因为如果用属性依赖的话，我们每次其实拿到的还是第一次初始化时候的 bean。 一种解决方案就是不要用属性依赖，每次获取依赖的 bean 的时候从 BeanFactory 中取。这个也是大家最常用的方式了吧。怎么取，我就不介绍了，大部分 Spring 项目大家都会定义那么个工具类的。 另一种解决方案就是这里要介绍的通过使用 Lookup method。 lookup-method我们来看一下 Spring Reference 中提供的一个例子： 1234567891011121314151617package fiona.apple;// no more Spring imports!public abstract class CommandManager { public Object process(Object commandState) { // grab a new instance of the appropriate Command interface Command command = createCommand(); // set the state on the (hopefully brand new) Command instance command.setState(commandState); return command.execute(); } // okay... but where is the implementation of this method? protected abstract Command createCommand();} xml 配置 &lt;lookup-method /&gt;： 123456789&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;&lt;bean id=\"myCommand\" class=\"fiona.apple.AsyncCommand\" scope=\"prototype\"&gt; &lt;!-- inject dependencies here as required --&gt;&lt;/bean&gt;&lt;!-- commandProcessor uses statefulCommandHelper --&gt;&lt;bean id=\"commandManager\" class=\"fiona.apple.CommandManager\"&gt; &lt;lookup-method name=\"createCommand\" bean=\"myCommand\"/&gt;&lt;/bean&gt; Spring 采用 CGLIB 生成字节码的方式来生成一个子类。我们定义的类不能定义为 final class，抽象方法上也不能加 final。 lookup-method 上的配置也可以采用注解来完成，这样就可以不用配置 &lt;lookup-method /&gt; 了，其他不变： 1234567891011public abstract class CommandManager { public Object process(Object commandState) { MyCommand command = createCommand(); command.setState(commandState); return command.execute(); } @Lookup(\"myCommand\") protected abstract Command createCommand();} 注意，既然用了注解，要配置注解扫描：&lt;context:component-scan base-package=&quot;com.javadoop&quot; /&gt; 甚至，我们可以像下面这样： 1234567891011public abstract class CommandManager { public Object process(Object commandState) { MyCommand command = createCommand(); command.setState(commandState); return command.execute(); } @Lookup protected abstract MyCommand createCommand();} 上面的返回值用了 MyCommand，当然，如果 Command 只有一个实现类，那返回值也可以写 Command。 replaced-method记住它的功能，就是替换掉 bean 中的一些方法。 12345678public class MyValueCalculator { public String computeValue(String input) { // some real code... } // some other methods...} 方法覆写，注意要实现 MethodReplacer 接口： 123456789public class ReplacementComputeValue implements org.springframework.beans.factory.support.MethodReplacer { public Object reimplement(Object o, Method m, Object[] args) throws Throwable { // get the input value, work with it, and return a computed result String input = (String) args[0]; ... return ...; }} 配置也很简单： 12345678&lt;bean id=\"myValueCalculator\" class=\"x.y.z.MyValueCalculator\"&gt; &lt;!-- 定义 computeValue 这个方法要被替换掉 --&gt; &lt;replaced-method name=\"computeValue\" replacer=\"replacementComputeValue\"&gt; &lt;arg-type&gt;String&lt;/arg-type&gt; &lt;/replaced-method&gt;&lt;/bean&gt;&lt;bean id=\"replacementComputeValue\" class=\"a.b.c.ReplacementComputeValue\"/&gt; arg-type 明显不是必须的，除非存在方法重载，这样必须通过参数类型列表来判断这里要覆盖哪个方法。 BeanPostProcessor应该说 BeanPostProcessor 概念在 Spring 中也是比较重要的。我们看下接口定义： 1234567public interface BeanPostProcessor { Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException; Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;} 看这个接口中的两个方法名字我们大体上可以猜测 bean 在初始化之前会执行 postProcessBeforeInitialization 这个方法，初始化完成之后会执行 postProcessAfterInitialization 这个方法。但是，这么理解是非常片面的。 首先，我们要明白，除了我们自己定义的 BeanPostProcessor 实现外，Spring 容器在启动时自动给我们也加了几个。如在获取 BeanFactory 的 obtainFactory() 方法结束后的 prepareBeanFactory(factory)，大家仔细看会发现，Spring 往容器中添加了这两个 BeanPostProcessor：ApplicationContextAwareProcessor、ApplicationListenerDetector。 我们回到这个接口本身，读者请看第一个方法，这个方法接受的第一个参数是 bean 实例，第二个参数是 bean 的名字，重点在返回值将会作为新的 bean 实例，所以，没事的话这里不能随便返回个 null。 那意味着什么呢？我们很容易想到的就是，我们这里可以对一些我们想要修饰的 bean 实例做一些事情。但是对于 Spring 框架来说，它会决定是不是要在这个方法中返回 bean 实例的代理，这样就有更大的想象空间了。 最后，我们说说如果我们自己定义一个 bean 实现 BeanPostProcessor 的话，它的执行时机是什么时候？ 如果仔细看了代码分析的话，其实很容易知道了，在 bean 实例化完成、属性注入完成之后，会执行回调方法，具体请参见类 AbstractAutowireCapableBeanFactory#initBean 方法。 首先会回调几个实现了 Aware 接口的 bean，然后就开始回调 BeanPostProcessor 的 postProcessBeforeInitialization 方法，之后是回调 init-method，然后再回调 BeanPostProcessor 的 postProcessAfterInitialization 方法。 总结按理说，总结应该写在附录前面，我就不讲究了。 在花了那么多时间后，这篇文章终于算是基本写完了，大家在惊叹 Spring 给我们做了那么多的事的时候，应该透过现象看本质，去理解 Spring 写得好的地方，去理解它的设计思想。 本文的缺陷在于对 Spring 预初始化 singleton beans 的过程分析不够，主要是代码量真的比较大，分支旁路众多。同时，虽然附录条目不少，但是庞大的 Spring 真的引出了很多的概念，希望日后有精力可以慢慢补充一些。 （全文完）","link":"/2020/02/16/20200216-ioc/"}],"tags":[{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"AOP","slug":"AOP","link":"/tags/AOP/"},{"name":"日常计划","slug":"日常计划","link":"/tags/%E6%97%A5%E5%B8%B8%E8%AE%A1%E5%88%92/"},{"name":"面试","slug":"面试","link":"/tags/%E9%9D%A2%E8%AF%95/"},{"name":"equals","slug":"equals","link":"/tags/equals/"},{"name":"hashcode","slug":"hashcode","link":"/tags/hashcode/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"Hello World","slug":"Hello-World","link":"/tags/Hello-World/"},{"name":"反向代理","slug":"反向代理","link":"/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"},{"name":"动静分离","slug":"动静分离","link":"/tags/%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB/"},{"name":"文件上传","slug":"文件上传","link":"/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"SpringMVC","slug":"SpringMVC","link":"/tags/SpringMVC/"},{"name":"负载均衡","slug":"负载均衡","link":"/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"name":"json","slug":"json","link":"/tags/json/"},{"name":"集群","slug":"集群","link":"/tags/%E9%9B%86%E7%BE%A4/"},{"name":"高可用模式","slug":"高可用模式","link":"/tags/%E9%AB%98%E5%8F%AF%E7%94%A8%E6%A8%A1%E5%BC%8F/"},{"name":"主从模式","slug":"主从模式","link":"/tags/%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/tags/SpringBoot/"},{"name":"Filter","slug":"Filter","link":"/tags/Filter/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Centos","slug":"Centos","link":"/tags/Centos/"},{"name":"项目部署","slug":"项目部署","link":"/tags/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"},{"name":"Thymeleaf","slug":"Thymeleaf","link":"/tags/Thymeleaf/"},{"name":"Interceptor","slug":"Interceptor","link":"/tags/Interceptor/"},{"name":"FTP","slug":"FTP","link":"/tags/FTP/"},{"name":"TCP/IP","slug":"TCP-IP","link":"/tags/TCP-IP/"},{"name":"IOC","slug":"IOC","link":"/tags/IOC/"}],"categories":[{"name":"Spring","slug":"Spring","link":"/categories/Spring/"},{"name":"面试","slug":"面试","link":"/categories/%E9%9D%A2%E8%AF%95/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"Nginx","slug":"Nginx","link":"/categories/Nginx/"},{"name":"生活","slug":"生活","link":"/categories/%E7%94%9F%E6%B4%BB/"},{"name":"SpringMVC","slug":"SpringMVC","link":"/categories/SpringMVC/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/categories/SpringBoot/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"TCP/IP","slug":"TCP-IP","link":"/categories/TCP-IP/"}]}