{"pages":[{"title":"关于我","text":"&emsp;&emsp;还没有想好该怎么样介绍自己，那就先这样吧！ &emsp;&emsp;我养了两只猫，一只叫豆浆，一只叫油条。","link":"/about/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"Hello World","text":"&emsp;&emsp;国际惯例，先来一篇Hello，World! &emsp;&emsp;终于完成了一直以来的一个梦想，搭建一个属于自己的博客。记录一下学习到的新技术，偶尔记录一下生活上的趣事也是极好的。博客采用了hexo，主题采用了icarus，项目仓库在GitHub。由于GitHub Pages的访问速度太慢了，所以就将仓库关联到了Gitee，托管在了Gitee Pages。由于域名还在备案的流程当中，所以暂时用了Gitee二级域名，后面会换到自己的域名。https://www.zlgwzy.com &emsp;&emsp;接下来就是把以前做的笔记整理一下上传到博客，方便以后回顾，同时也加深了印象。 &emsp;&emsp;由于疫情的原因，一直宅在家学习准备面试。希望早点控制好疫情，就能够出去找工作面试了，希望能找到满意的工作。","link":"/2020/02/15/hello-world/"},{"title":"重写equals方法为什么要重写hashcode?","text":"1.要讨论这个问题必须先明白==和equals的区别&emsp;&emsp;== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)。 &emsp;&emsp;equals():它的作用也是判断两个对象是否相等。但它一般有两种使用情况： 情况1：类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于通过”==”比较这两个对象。 情况2：类覆盖了equals()方法。一般，我们都覆盖equals()方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。 &emsp;&emsp;基本数据类型的包装类为引用类型，其中的equals()方法等价于”==”,以下为Integer的equals()方法: 1234567public boolean equals(Object obj) { if (obj instanceof Integer) { return this.value == (Integer)obj; } else { return false; }} &emsp;&emsp;String的equsle()方法被重写过，比较的是对象的值是否相等。 1234567891011121314public boolean equals(Object anObject) { if (this == anObject) { return true; } else { if (anObject instanceof String) { String aString = (String)anObject; if (this.coder() == aString.coder()) { return this.isLatin1() ? StringLatin1.equals(this.value, aString.value) : StringUTF16.equals(this.value, aString.value); } } return false; }} &emsp;&emsp;object的equals()方法比较的是对象的内存地址是否相等。 123public boolean equals(Object obj) { return this == obj;} 2.什么是hashcode()?&emsp;&emsp;hashcode()的作用是获取哈希码，返回一个int类型的整数。哈希码的作用是确定对象在哈希表中的索引位置。hashCode()定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode()函数。计算hash值是根据对象堆内存上地址转换成一个整数hash值。 引用JavaGuide教程里面的一段话:3.为什么要有hashCode&emsp;&emsp;我们先以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode： 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashCode 值作比较，如果没有相符的hashCode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashCode 值的对象，这时会调用 equals()方法来检查 hashCode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。 4.hashCode与equals()的相关规定 如果两个对象相等，则hashCode一定相同 两个对象相等，两个对象分别调用equals()方法都返回true 两个对象有相同的hashCode值，它们不一定相同(两个对象hashCode的值相同，但是equals为false，就会被散列在散列表的不同位置) hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode(),则该class的两个对象无论如何都不会相等(即使这两个对象是相同的数据) 因此，equals()方法被覆盖过，则hashCode()方法也必须被覆盖 5.为什么重写equals()方法的时候必须要重写hashCode()?&emsp;&emsp;重写equals()的目的是有的时候我们只需要判断两个对象的某些属性相等就认为它们相等，如果此时不重写hashCode(),基于堆内存地址的散列值除非产生hash冲突，那不然两个对象hashCode()必定不相等。如果不重写hashCode(),两个逻辑上相等的对象会被散列在散列表的不同位置。 重写equals()，重写hashCode(): 123456789101112 Book b1 = new Book(1,&quot;三国演义&quot;,&quot;罗贯中&quot;); Book b2 = new Book(1,&quot;三国演义&quot;,&quot;罗贯中&quot;); System.out.println(b1.equals(b2)); System.out.println(b1==b2); System.out.println(b1.hashCode()); System.out.println(b2.hashCode());运行结果: true false 1993172716 1993172716 重写equals()，不重写hashCode(): 123456789101112 Book b1 = new Book(1,&quot;三国演义&quot;,&quot;罗贯中&quot;); Book b2 = new Book(1,&quot;三国演义&quot;,&quot;罗贯中&quot;); System.out.println(b1.equals(b2)); System.out.println(b1==b2); System.out.println(b1.hashCode()); System.out.println(b2.hashCode());运行结果: true false 1989495347 614635686 6.补充：什么是堆内存和栈内存？ 在Java中，栈(stack)是由编译器自动分配和释放的一块内存区域，主要用于存放一些基本类型（如int、float等）的变量、指令代码、常量及对象句柄（也就是对象的引用地址） 堆（heap）是一个程序运行动态分配的内存区域，在Java中，构建对象时所需要的内存从堆中分配。这些对象通过new指令“显式”建立，这种分配方式类似于数据结构中的链表。堆内存在使用完毕后，是由垃圾回收（Garbage Collection,GC）器“隐式”回收的。","link":"/2020/02/15/equals-hashcode/"},{"title":"面试前的一些针对性复习计划","text":"1.准备面试的公司技术要求 熟练掌握IDEA开发工具，良好的编码习惯和风格 熟练SpringMVC、SpringBoot、mybatis等开发框架 良好的数据库知识mysql、redis、oracle、MQ等，强sql能力 熟练使用linux常用命令、环境配置 熟练使用Tomcat、Nginx等服务部署 熟悉maven环境 了解前端具备一定的开发经验，基本掌握：html、html5、css、css3，熟练掌握js代码编写，页面兼容性处理。 熟练运用关系型数据库：musql/oracle，具备一定的数据库表设计经验 2.自己不足的地方和学习计划 SpringMVC，熟悉一下xml配置和框架流程 mybatis熟悉一下相关的标签和注解 redis和MQ掌握一下高级用法，实际写点demo 熟悉Nginx服务部署 熟悉maven私服 熟悉js代码，jQuery 3.鼓励一下自己&emsp;&emsp;有多个前后端分离全栈开发经验，熟练使用vue和element-ui，前端应该不存在多大问题，了解一下性能优化。每天按着计划多复习和学习一点东西，找工作的时候肯定没问题。不用害怕面试，面试只不过是对自己技术做一个测试而已。踏踏实实的做好每一步，必能有所收获。","link":"/2020/02/15/interview/"},{"title":"Spring AOP的实现原理","text":"1.Spring中关于AOP的定义如下:&emsp;&emsp;面向切面——Spring提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务（例如审计（auditing）和事务（transaction）管理）进行内聚性的开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责（甚至是意识）其它的系统级关注点，例如日志或事务支持。 &emsp;&emsp;面向切面是面向对象的一种方式，在代码执行的过程当中，动态嵌入其它代码。 &emsp;&emsp;常见使用场景:&emsp;&emsp;1.日志&emsp;&emsp;2.事务&emsp;&emsp;3.数据库操作 2.AOP的几个核心概念&emsp;&emsp;AOP本质上是Java动态代理 通知(Advice)5种通知类型: Before 在方法被调用之前调用 After 在方法完成后调用通知，无论方法是否执行成功 After-returning 在方法成功执行之后调用通知 After-throwing 在方法抛出异常后调用通知 Around 环绕通知，在被通知的方法之前或者之后自定义是否执行被通知的方法 切点(Pointcut)切点在Spring AOP中对应系统中的方法,这个方法是定义在切面中的方法，一般和通知一起使用，一起组成了切面。 连接点(Join point)连接点就是准备在系统中执行切点和切入通知的地方(一般是一个方法，一个字段) 切面(Aspect)切面是切点和通知的集合，一般单独作为一个类。通知和切点共同定义了关于切面的全部内容，在何时和何处完成什么功能。 引入(Introduction)引入允许我们向现有的类添加新的方法或者属性。 织入(Weaving)创建一个被通知对象。这可以在编译时完成（例如使用AspectJ编译器），也可以在运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。 3.Spring中对AOP的支持&emsp;&emsp;首先AOP思想的实现一般都是基于代理模式，在JAVA中一般采用JDK动态代理模式，但是我们都知道，JDK动态代理模式只能代理接口，如果要代理类那么就不行了。因此，Spring AOP 会这样子来进行切换，因为Spring AOP 同时支持 CGLIB、ASPECTJ、JDK动态代理，当你的真实对象有实现接口时，Spring AOP会默认采用JDK动态代理，否则采用cglib代理。 如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类。 如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类——不过这个选择过程对开发者完全透明、开发者也无需关心。 4.代码实现Java动态代理(定义一个计算器作为例子) 定义一个接口12345public interface Calculator { int add(int a, int b); void min(int a, int b);} 定义接口的实现类1234567891011121314public class CalculatorImpl implements Calculator { //有返回值 @Override public int add(int a, int b) { System.out.println(a + &quot;+&quot; + b + &quot;=&quot; + (a + b)); return a + b; } //无返回值 @Override public void min(int a, int b) { System.out.println(a + &quot;-&quot; + b + &quot;=&quot; + (a - b)); }} 动态代理类1234567891011121314151617181920212223242526public class MyProxy { /** * @param o 被代理的对象 * @return 返回值是代理后的对象 */ public Object getInstance(Object o){ return Proxy.newProxyInstance(o.getClass().getClassLoader(), o.getClass().getInterfaces(), new InvocationHandler() { /** * 被代理过后的对象返回值变为invoke方法的返回值 * @param proxy 被代理的对象 * @param method 被代理的方法 * @param args 被代理的方法的参数 * @return 方法的返回值 * @throws Throwable */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { long start = System.nanoTime(); Object invoke = method.invoke(o, args); long end = System.nanoTime(); System.out.println(end - start); return invoke; } }); }} main方法12345678public class Main { public static void main(String[] args) { //获取代理对象 Calculator instance = (Calculator) new MyProxy().getInstance(new CalculatorImpl()); instance.add(9,8); instance.min(4,5); }} &emsp;&emsp;被动态代理过后的对象可以轻松的进行如打印日志等的操作，AOP的引入可以更加灵活方便，实现动态配置。","link":"/2020/02/16/aop/"},{"title":"SpringMVC工作原理详解(转载自SnailClimb在GitHub的开源项目JavaGide)","text":"原作者开源项目地址 JavaGuide 1.先来看一下什么是MVC模式&emsp;&emsp;MVC是一种设计模式&emsp;&emsp;MVC的原理图如下: 2.SpringMVC简单介绍&emsp;&emsp;SpringMVC框架是以请求为驱动,围绕Servlet设计,将请求发给控制器,然后通过模型对象,分派器来展示请求结果视图。其中核心类是 DispatcherServlet,它是一个Servlet,顶层是实现的Servlet接口。 3.SpringMVC使用&emsp;&emsp;需要在web.xml中配置DispatcherServlet。并且需要配置Spring监听器ContextLoaderListener 12345678910111213141516171819&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt;&lt;/listener&gt;&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet &lt;/servlet-class&gt; &lt;!-- 如果不设置init-param标签，则必须在/WEB-INF/下创建xxx-servlet.xml文件，其中xxx是servlet-name中配置的名称。 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 4.SpringMVC工作原理(重要)简单来说:&emsp;&emsp;客户端发送请求-&gt;前端控制器DispatcherServlet接受客户端请求-&gt;找到处理器映射HandlerMapping解析请求对应的Handler-&gt;HandlerAdapter会根据Handler来调用真正的处理器处理请求,并处理相应的业务逻辑-&gt;处理器返回一个模型视图ModelAndView-&gt;视图解析器进行解析-&gt;返回一个视图对象-&gt;前端控制器DispatcherServlet渲染数据(Moder)-&gt;将得到视图对象返回给用户。如下图所示: 流程说明(重要): 客户端(浏览器)发送请求,直接请求到DispatcherServlet。 DispatcherServlet根据请求信息调用HandlerMapping,解析请求对应的Handler。 解析到对应的Handler(也就是我们平常说的Controller控制器)后,开始由HandlerAdapter适配器处理。 HandlerAdapter会根据Handler来调用真正的处理器处理请求,并处理相应的业务逻辑。 处理器处理完业务后,会返回一个ModelAndView对象,Model是返回的数据对象,View是个逻辑上的View。 ViewResolver会根据逻辑View查找实际的View。 DispaterServlet把返回的Model传给View(视图渲染) 把View返回给请求者(浏览器) 5.SpringMVC重要组件说明 前端控制器DispatcherServlet(不需要工程师开发),由框架提供(重要)作用:SpringMVC的入口函数。接收请求,响应结果,相当于转发器,中央处理器。有了DispatcherServlet减少了其它组件之间的耦合度。用户请求到达前端控制器,它就相当于mvc模式中的c,DispatcherServlet是整个流程控制的中心,由它调用其它组件处理用户的请求,DispatcherServlet的存在降低了组件之间的耦合性。 处理器映射器HandlerMapping(不需要工程师开发),由框架提供作用:根据请求的url查找Handler。HandlerMapping负责根据用户请求找到Handler即处理器(Controller),SpringMVC提供了不同的映射器实现不同的映射方式。例如:配置文件方式,实现接口方式,注解方式等。 处理器适配器HandlerAdapter作用:按照特定规则(HandlerAdapter要求的规则)去执行Handler通过HandlerAdapter对处理器进行执行,这是适配器模式的应用,通过扩展适配器可以对更多类型的处理器进行执行。 处理器Handler(需要工程师开发)注意:编写Handler时按照HandlerAdapter的要求去做,这样适配器才可以去正确执行Handler,Handler是继DispatcherServlet前端控制器的后端控制器,在DispatcherServlet的控制下Handler对具体的用户请求进行处理。 由于Handler涉及到具体的用户业务请求,所以一般情况需要工程师根据业务需求开发Handler。 视图解析器View resolver(不需要工程师开发),由框架提供作用:进行视图解析,根据逻辑视图名解析成真正的视图(view)ViewResolver负责将处理结果生成View视图,ViewResolver首先根据逻辑视图名解析成物理视图名即具体的页面地址,再生成View视图对象,最后对View进行渲染将处理结果通过页面展示给用户。 springmvc框架提供了很多的View视图类型,包括:jstlView、freemarkerView、pdfView等。 一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户,需要由工程师根据业务需求开发具体的页面。 视图View(需要工程师开发)View是一个接口，实现类支持不同的View类型(jsp、freemarker、pdf…) 注意:处理器Handler(也就是我们平常说的Controller控制器)以及视图层view都是需要我们自己手动开发的。其他的一些组件比如:前端控制器DispatcherServlet、处理器映射器HandlerMapping、处理器适配器HandlerAdapter等等都是框架提供给我们的,不需要自己手动开发。 6.DispatcherServlet详细解析首先看下源码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package org.springframework.web.servlet;@SuppressWarnings(&quot;serial&quot;)public class DispatcherServlet extends FrameworkServlet { public static final String MULTIPART_RESOLVER_BEAN_NAME = &quot;multipartResolver&quot;; public static final String LOCALE_RESOLVER_BEAN_NAME = &quot;localeResolver&quot;; public static final String THEME_RESOLVER_BEAN_NAME = &quot;themeResolver&quot;; public static final String HANDLER_MAPPING_BEAN_NAME = &quot;handlerMapping&quot;; public static final String HANDLER_ADAPTER_BEAN_NAME = &quot;handlerAdapter&quot;; public static final String HANDLER_EXCEPTION_RESOLVER_BEAN_NAME = &quot;handlerExceptionResolver&quot;; public static final String REQUEST_TO_VIEW_NAME_TRANSLATOR_BEAN_NAME = &quot;viewNameTranslator&quot;; public static final String VIEW_RESOLVER_BEAN_NAME = &quot;viewResolver&quot;; public static final String FLASH_MAP_MANAGER_BEAN_NAME = &quot;flashMapManager&quot;; public static final String WEB_APPLICATION_CONTEXT_ATTRIBUTE = DispatcherServlet.class.getName() + &quot;.CONTEXT&quot;; public static final String LOCALE_RESOLVER_ATTRIBUTE = DispatcherServlet.class.getName() + &quot;.LOCALE_RESOLVER&quot;; public static final String THEME_RESOLVER_ATTRIBUTE = DispatcherServlet.class.getName() + &quot;.THEME_RESOLVER&quot;; public static final String THEME_SOURCE_ATTRIBUTE = DispatcherServlet.class.getName() + &quot;.THEME_SOURCE&quot;; public static final String INPUT_FLASH_MAP_ATTRIBUTE = DispatcherServlet.class.getName() + &quot;.INPUT_FLASH_MAP&quot;; public static final String OUTPUT_FLASH_MAP_ATTRIBUTE = DispatcherServlet.class.getName() + &quot;.OUTPUT_FLASH_MAP&quot;; public static final String FLASH_MAP_MANAGER_ATTRIBUTE = DispatcherServlet.class.getName() + &quot;.FLASH_MAP_MANAGER&quot;; public static final String EXCEPTION_ATTRIBUTE = DispatcherServlet.class.getName() + &quot;.EXCEPTION&quot;; public static final String PAGE_NOT_FOUND_LOG_CATEGORY = &quot;org.springframework.web.servlet.PageNotFound&quot;; private static final String DEFAULT_STRATEGIES_PATH = &quot;DispatcherServlet.properties&quot;; protected static final Log pageNotFoundLogger = LogFactory.getLog(PAGE_NOT_FOUND_LOG_CATEGORY); private static final Properties defaultStrategies; static { try { ClassPathResource resource = new ClassPathResource(DEFAULT_STRATEGIES_PATH, DispatcherServlet.class); defaultStrategies = PropertiesLoaderUtils.loadProperties(resource); } catch (IOException ex) { throw new IllegalStateException(&quot;Could not load 'DispatcherServlet.properties': &quot; + ex.getMessage()); } } /** Detect all HandlerMappings or just expect &quot;handlerMapping&quot; bean? */ private boolean detectAllHandlerMappings = true; /** Detect all HandlerAdapters or just expect &quot;handlerAdapter&quot; bean? */ private boolean detectAllHandlerAdapters = true; /** Detect all HandlerExceptionResolvers or just expect &quot;handlerExceptionResolver&quot; bean? */ private boolean detectAllHandlerExceptionResolvers = true; /** Detect all ViewResolvers or just expect &quot;viewResolver&quot; bean? */ private boolean detectAllViewResolvers = true; /** Throw a NoHandlerFoundException if no Handler was found to process this request? **/ private boolean throwExceptionIfNoHandlerFound = false; /** Perform cleanup of request attributes after include request? */ private boolean cleanupAfterInclude = true; /** MultipartResolver used by this servlet */ private MultipartResolver multipartResolver; /** LocaleResolver used by this servlet */ private LocaleResolver localeResolver; /** ThemeResolver used by this servlet */ private ThemeResolver themeResolver; /** List of HandlerMappings used by this servlet */ private List&lt;HandlerMapping&gt; handlerMappings; /** List of HandlerAdapters used by this servlet */ private List&lt;HandlerAdapter&gt; handlerAdapters; /** List of HandlerExceptionResolvers used by this servlet */ private List&lt;HandlerExceptionResolver&gt; handlerExceptionResolvers; /** RequestToViewNameTranslator used by this servlet */ private RequestToViewNameTranslator viewNameTranslator; private FlashMapManager flashMapManager; /** List of ViewResolvers used by this servlet */ private List&lt;ViewResolver&gt; viewResolvers; public DispatcherServlet() { super(); } public DispatcherServlet(WebApplicationContext webApplicationContext) { super(webApplicationContext); } @Override protected void onRefresh(ApplicationContext context) { initStrategies(context); } protected void initStrategies(ApplicationContext context) { initMultipartResolver(context); initLocaleResolver(context); initThemeResolver(context); initHandlerMappings(context); initHandlerAdapters(context); initHandlerExceptionResolvers(context); initRequestToViewNameTranslator(context); initViewResolvers(context); initFlashMapManager(context); }} DispatcherServlet类中的属性beans: HandlerMapping：用于handlers映射请求和一系列的对于拦截器的前处理和后处理，大部分用@Controller注解。 HandlerAdapter：帮助DispatcherServlet处理映射请求处理程序的适配器，而不用考虑实际调用的是 哪个处理程序。 ViewResolver：根据实际配置解析实际的View类型。 ThemeResolver：解决Web应用程序可以使用的主题，例如提供个性化布局。 MultipartResolver：解析多部分请求，以支持从HTML表单上传文件。 FlashMapManager：存储并检索可用于将一个请求属性传递到另一个请求的input和output的FlashMap，通常用于重定向。 &emsp;&emsp;在Web MVC框架中，每个DispatcherServlet都拥自己的WebApplicationContext，它继承了ApplicationContext。WebApplicationContext包含了其上下文和Servlet实例之间共享的所有的基础框架beans。 HandlerMapping HandlerMapping接口处理请求的映射HandlerMapping接口的实现类: SimpleUrlHandlerMapping类通过配置文件把URL映射到Controller类。 DefaultAnnotationHandlerMapping类通过注解把URL映射到Controller类。 HandlerAdapter HandlerAdapter接口-处理请求映射 AnnotationMethodHandlerAdapter：通过注解，把请求URL映射到Controller类的方法上。 HandlerExceptionResolver HandlerExceptionResolver接口-异常处理接口 SimpleMappingExceptionResolver通过配置文件进行异常处理。 AnnotationMethodHandlerExceptionResolver：通过注解进行异常处理。 ViewResolver ViewResolver接口解析View视图。UrlBasedViewResolver类 通过配置文件，把一个视图名交给到一个View来处理。","link":"/2020/02/16/springmvc/"}],"tags":[{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"Hello World","slug":"Hello-World","link":"/tags/Hello-World/"},{"name":"equals","slug":"equals","link":"/tags/equals/"},{"name":"hashcode","slug":"hashcode","link":"/tags/hashcode/"},{"name":"日常计划","slug":"日常计划","link":"/tags/%E6%97%A5%E5%B8%B8%E8%AE%A1%E5%88%92/"},{"name":"面试","slug":"面试","link":"/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"AOP","slug":"AOP","link":"/tags/AOP/"},{"name":"SpringMVC","slug":"SpringMVC","link":"/tags/SpringMVC/"}],"categories":[{"name":"生活","slug":"生活","link":"/categories/%E7%94%9F%E6%B4%BB/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"面试","slug":"面试","link":"/categories/%E9%9D%A2%E8%AF%95/"},{"name":"Spring","slug":"Spring","link":"/categories/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","link":"/categories/SpringMVC/"}]}